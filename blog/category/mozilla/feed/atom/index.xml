<?xml version="1.0" encoding="UTF-8"?>
<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
   >
  <title type="text">Gregory Szorc's Digital Home</title>
  <subtitle type="text">Rambling on</subtitle>

  <updated>2013-05-13T20:31:28Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog" />
  <id>http://gregoryszorc.com/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://gregoryszorc.com/blog/feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[The State of Mercurial at Mozilla]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/05/13/the-state-of-mercurial-at-mozilla" />
    <id>http://gregoryszorc.com/blog/2013/05/13/the-state-of-mercurial-at-mozilla</id>
    <updated>2013-05-13T13:25:00Z</updated>
    <published>2013-05-13T13:25:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[The State of Mercurial at Mozilla]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/05/13/the-state-of-mercurial-at-mozilla"><![CDATA[<p>I have an opinion on the usage of Mercurial at Mozilla: it stinks.</p>
<p>Here's why.</p>
<h2>The server is configured poorly</h2>
<p>Our Mozilla server, hg.mozilla.org, is currently running Mercurial 2.0.2.
In terms of Mercurial features, stability, and performance, we are light
years behind.</p>
<p>You know that annoying phases configuration you need to set when pushing
to Try? That's because the server isn't new enough to tell the client the
same thing the configuration option does. It
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=725362">will be fixed</a>
when the server is upgraded to 2.1+.</p>
<p>Furthermore, we are running the server over NFS, which introduces known
badness, including slowness.</p>
<p>I believe we blame Mercurial for issues that would go away if we
configured the Mercurial server properly.</p>
<p>Fortunately, it appears the
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=781012">upgrade to 2.5</a>
is near and I've heard we're moving from NFS to local disk storage as
part of that. This should go a long way to making the server better.
The upgrade can't happen soon enough.</p>
<h2>User education is poor</h2>
<p>I think a lot of people are ignorant on the features and abilities of
Mercurial.</p>
<p>I commonly hear people are dissatisfied with the behavior of their
Mercurial client. They encounter performance issues, bugs, corruption,
etc. Nine times out of ten this is due to running an old Mercurial
release. Just last Friday someone on my team asked me about
weird behavior involving file case. My first question: <em>what version
of Mercurial are you using?</em> He was running 2.0.2. I told him to
upgrade to 2.5+. It fixed his problem. <strong>If you aren't running
Mercurial 2.5 or newer, upgrade immediately.</strong></p>
<p>I've heard people say we should switch to Git because Git has feature X.
Most of the time, Mercurial has these features. Unfortunately, people
just don't realize it. When I point them at
<a href="http://mercurial.selenic.com/wiki/UsingExtensions">Mercurial's extensions list</a>
their eyes light up and they thank me for making their lives easier.</p>
<p>I think a problem is a lot of new Mozilla contributors knew Git
before and only pick up the bare essentials of Mercurial that allow them
to land patches. They prefer Git because it is familiar and just don't
bother to pick up Mercurial. The potential of Mercurial is thus lost on
them.</p>
<p>Perhaps we should have a brown bag and/or better documentation on
getting the most out of Mercurial?</p>
<h2>The branching model is far from ideal</h2>
<p>For Gecko/Firefox development, we maintain separate repositories for the
trunk and release branches. This introduces all kinds of annoying.</p>
<p>We should not have separate repositories for <em>central</em>, <em>inbound</em>,
<em>aurora</em>, <em>beta</em>, <em>release</em>, etc. We should be using some combination of
branches and bookmarks and have all the release heads in one
repository, just like how the
<a href="https://github.com/mozilla/mozilla-central/">GitHub mirror</a> is
configured.</p>
<p>As an experiment, I created a
<a href="https://hg.mozilla.org/users/gszorc_mozilla.com/gecko">unified Mercurial repository</a>.
Each current repository is tracked as a bookmark (there are
<a href="https://developer.mozilla.org/en-US/docs/Developer_Guide/Source_Code/Mercurial">instructions</a>
for reproducing this). Unfortunately, the web interface isn't showing
bookmarks (perhaps because the version of Mercurial is too old?), so
you'll have to clone the repository to play around. Just run
<em>hg bookmarks</em> and e.g. <em>hg up aurora</em> after cloning.
<em>Warning: I'm not actively synchronizing this repository, so don't rely
on it being up to date</em>.</p>
<p>A Mercurial contributor (who is familiar with Mozilla's
development model) suggested we use Mercurial branches for every Gecko
release (20, 21, 22, etc). I think this and other uses of branches and
bookmarks are ideas worth exploring.</p>
<h2>We're failing to harness the extensibility</h2>
<p>Gecko/Firefox has a complicated code lifecycle and landing process.
This could be significantly streamlined if we fully harnessed and
embraced the extensibility of Mercurial. While there are some
Mozilla-centric extensions (details in my
<a href="/blog/2013/05/12/thoughts-on-mercurial-%28and-git%29/">recent post</a>),
I don't think they are well known nor used.</p>
<p>I think Mozilla should embrace the functionality of extensions like
these (whether they be for Mercurial, Git, or something else) and invest
resources in improving the workflows for all developers. Until these
tools are obviously superior and advertised, I believe many developers
will unknowingly continue to toil without them. And, it's likely hurting
our ability to attract and retain new contributors as well.</p>
<h2>Conclusion</h2>
<p>Mozilla's current usage of Mercurial is far from ideal. It's no wonder
people don't like Mercurial (and why some want to switch to Git).</p>
<p>Fortunately, little has to do with shortcomings of Mercurial itself (at
least with newer versions). If you want to know why Mercurial isn't
working too well for Gecko/Firefox development, most of the problems
are self-inflicted or the solutions reside within each of us. Time
will tell if we as a community have the will to address these issues.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Thoughts on Mercurial (and Git)]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/05/12/thoughts-on-mercurial-(and-git)" />
    <id>http://gregoryszorc.com/blog/2013/05/12/thoughts-on-mercurial-(and-git)</id>
    <updated>2013-05-12T12:00:00Z</updated>
    <published>2013-05-12T12:00:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Git" />
    <summary type="html"><![CDATA[Thoughts on Mercurial (and Git)]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/05/12/thoughts-on-mercurial-(and-git)"><![CDATA[<p>My first experience with Mercurial (Firefox development)
was very unpleasant. Coming from Git, I thought Mercurial was slow
and perhaps even more awkward to use than Git. I frequently
encountered repository corruption that required me to reclone. I thought
the concept of a patch queue was silly compared to Git branches. It
was all extremely frustrating and I dare say a hinderance to my
productivity. It didn't help that I was surrounded by a bunch of people
who had previous experience with Git and opined about every minute
difference.</p>
<p>Two years later and I'm on much better terms with Mercurial. I initially
thought it might be Stockholm Syndrome, but after reflection I can point
at specific changes and enlightenments that have reshaped my opinions.</p>
<h2>Newer versions of Mercurial are much better</h2>
<p>I first started using Mercurial in the 1.8 days and thought it was
horrible. However, modern releases are much, much better. I've noticed
a steady improvement in the quality and speed of Mercurial in the last
few years.</p>
<p><strong>If you aren't running 2.5 or later (Mercurial 2.6 was released earlier
this month), you should take the time to upgrade today.</strong> When you upgrade,
you should of course read the
<a href="http://mercurial.selenic.com/wiki/WhatsNew">changelog</a> and
<a href="http://mercurial.selenic.com/wiki/UpgradeNotes">upgrade notes</a> so you
can make the most of the new features.</p>
<h2>Proper configuration is key</h2>
<p>For <em>my</em> workflow, the default configuration of Mercurial out of the box
is... far from optimal. There are a number of basic changes that need to
be made to satisfy <em>my</em> expectations for a version control tool.</p>
<p>I used to think this was a shortcoming with Mercurial: why not ship a
powerful and useful environment out of the box? But, after talking to a
Mercurial core contributor, this is mostly by design. Apparently a
principle of the Mercurial project is that the CLI tool (<em>hg</em>) should be
simple by default and should minimize foot guns. They view actions like
rebasing and patch queues as advanced and thus don't have them enabled
by default. Seasoned developers may scoff at this. But, I see where
Mercurial is coming from. I only need to refer everyone to her first
experience with Git as an example of what happens when you don't aim for
simplicity. (I've never met a Git user who didn't think it overly
complicated at first.)</p>
<p>Anyway, to get the most out of Mercurial, it is essential to configure
it to your liking, much like you install plugins or extensions in your
code editor.</p>
<p><strong>Every person running Mercurial should go to
<a href="http://mercurial.selenic.com/wiki/UsingExtensions">http://mercurial.selenic.com/wiki/UsingExtensions</a>
and take the time to find extensions that will make your life better</strong>.
You should also run <em>hg help hgrc</em> to view all the configuration
options. There is a mountain of productivity wins waiting to be realized.</p>
<p>For reference, my <a href="https://gist.github.com/indygreg/5511712">~/.hgrc</a>.
Worth noting are some of the built-in externsions I've enabled:</p>
<ul>
<li>color - Colorize terminal output. Clear UX win.</li>
<li>histedit - Provides  <em>git rebase --interactive</em> behavior.</li>
<li>pager - Feed command output into a pager (like <em>less</em>). Clear UX win.</li>
<li>progress - Draw progress bars on long-running operations. Clear UX
  win.</li>
<li>rebase - Ability to easily rebase patches on top of other heads.
  This is a basic feature of patch management.</li>
<li>transplant - Easily move patches between repositories, branches, etc.</li>
</ul>
<p>If I were on Linux, I'd also use the <em>inotify</em> extension, which installs
filesystem watchers so operations like <em>hg status</em> are instantaneous.</p>
<p>In addition to the built-in extensions, there are a number of 3rd party
extensions that improve my Mozilla workflow:</p>
<ul>
<li><a href="https://bitbucket.org/sfink/mqext">mqext</a> - Automatically commit to
  your patch queue when you qref, etc. This is a lifesaver. If that's
  not enough, it suggests reviewers for your patch, suggests a bug
  component, and let's you find bugs touching the files you are
  touching.</li>
<li><a href="https://github.com/pbiggar/trychooser">trychooser</a> - Easily push
  changes to Mozilla's Try infrastructure.</li>
<li><a href="https://hg.mozilla.org/users/robarnold_cmu.edu/qimportbz">qimportbz</a> -
  Easily import patches from Bugzilla.</li>
<li><a href="https://hg.mozilla.org/users/tmielczarek_mozilla.com/bzexport">bzexport</a> -
  Easily export patches to Bugzilla.</li>
</ul>
<p>I'm amazed more developers don't use these simple productivity wins.
Could it be that people simply don't realize they are available?</p>
<p>Mozilla has a <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=794580">bug</a>
tracking easier configuration of the user's Mercurial environment. My
hope is one day people simply run a single command and get a
Mozilla-optimized Mercurial environment that <em>just works</em>. Along the same
vein, if your extensions are out of date, it prompts you to update them.
This is one of the benefits of a unified developer tool like mach: you
can put these checks in one place and everyone can reap the benefits
easily.</p>
<h2>Mercurial is extensible</h2>
<p>The major differentiator from almost every other version control system
(especially Git) is the ease and degree to which Mercurial can be
extended and contorted. <strong>If you take anything away from this
post it should be that Mercurial is a flexible and agile tool.</strong></p>
<p>If you want to change the behavior of a built-in command, you can write
an extension that monkeypatches that command. If you want to write a new
command, you can of course do that easily. You can have extensions
interact with one another - all natively. You can even override the wire
protocol to provide new <em>capabilities</em> to extend how peers communicate
with one another. You can leverage this to transfer additional metadata
or data types. This has nearly infinite potential. If that's not enough,
it's possible to create a new branching/development primitive through
just an extension alone! If you want to invent Git-style branches with
Mercurial, you could do that! It may require client and server support,
but it's possible.</p>
<p>Mercurial accomplishes this by being written (mostly) in Python (as
opposed to C) and by having a clear API on which extensions can be
built. Writing extensions in Python is huge. You can easily drop into
the debugger to learn the API and your write-test loop is much smaller.</p>
<p>By contrast, most other version control systems (including Git) require
you to parse output of commands (this is the UNIX piping principle).
Mercurial supports this too, but the native Python API is so much more
powerful. Instead of parsing output, you can just read the raw values
from a Python data structure. Yes please.</p>
<p>Since I imagine a lot of people at Mozilla will be reading this, here
are some ways Mozilla could leverage the extensibility of Mercurial:</p>
<ul>
<li>Command to create try pushes (it exists - see above).</li>
<li>Record who pushed what when (we have this - it's called the pushlog).</li>
<li>Command to land patches. If inbound1 is closed,
  automatically rebase on inbound2. etc. This could even be
  monkeypatched into <em>hg push</em> so pushes to inbound are automatically
  intercepted and magic ensues.</li>
<li>Record the automation success/fail status against individual
  revisions and integrate with commands (e.g. only pull up to the most
  recent stable changeset).</li>
<li>Command to create a review request for a patch or patch queue.</li>
<li>Command to assist with reviews. Perhaps a reviewer wants to make minor
  changes. Mercurial could download and apply the patch(es), wait for
  your changes, then reupload to Bugzilla (or the review tool)
  automatically.</li>
<li>Annotating commits or pushes with automation info (which jobs to
  run, etc).</li>
<li>Find Bugzilla component for patch (it exists - see above).</li>
<li>Expose custom protocol for configuring automation settings for a
  repository or a head. e.g. clients (with access) could reconfigure
  PGO scheduling, coalescing, etc without having to involve RelEng -
  useful for twigs and lesser used repositories.</li>
<li>So much more.</li>
</ul>
<p>Essentially, Mercurial itself could become the CLI tool code development
centers around. Whether that is a good idea is up for
debate. But, it can. And that says a lot about the flexibility of
Mercurial.</p>
<h2>Future potential of Mercurial</h2>
<p>When you consider the previous three points, you arrive at a new one:
Mercurial has a ton of future potential. The fact that extensions can
evolve vanilla Mercurial into something that resembles Mercurial in
name only is a testament to this.</p>
<p>When I sat down with a Mercurial core contributor, they reinforced this.
To them, Mercurial is a core library with a limited set of user-facing
commands forming the stable API. Since core features (like storage) are
internal APIs (not public commands - like Git), this means they aren't
bound to backwards compatibility and can refactor internals as needed
and evolve over time without breaking the world. That is a terrific
luxury.</p>
<p>An example of this future potential is
<a href="http://mercurial.selenic.com/wiki/ChangesetEvolution">changeset evolution</a>.
If you don't know what that is, you should because it's awesome. One of
the things they figured out is how to propagate rebasing between
clones!</p>
<h2>Comparing to Git</h2>
<p>Two years ago I would have said I would never opt to use Mercurial over
Git. I cannot say that today.</p>
<p>I do believe Git still has the advantage over Mercurial in a few areas:</p>
<ul>
<li>Branch management. Mercurial branches are a non-starter for
  light-weigh work. Mercurial bookmarks are kinda-sorta like Git
  branches, but not quite. I <em>really</em> like aspects of Git branches.
  Hopefully changeset evolution will cover the remaining gaps and more.</li>
<li>Patch conflict management. Git seems to do a better job of resolving
  patch conflicts. But, I think this is mostly due to Mercurial's patch
  queue extension not using the same merge code as built-in commands
  (this is a fixable problem).</li>
<li>Developer mind share and GitHub. The GitHub ecosystem makes up for
  many of Git's shortcomings. Bitbucket isn't the same.</li>
</ul>
<p>However, I believe Mercurial has the upper hand for:</p>
<ul>
<li>Command line friendliness. Git's command line syntax is notoriously
  awful and the concepts can be difficult to master.</li>
<li>Extensibility. It's so easy to program custom workflows and commands
  with Mercurial. If you want to hack your version control system,
  Mercurial wins hands down. Where Mercurial embraces extensibility, I
  couldn't even find a page listing all the useful Git <em>extensions</em>!</li>
<li>Open source culture. Every time I've popped into the Mercurial IRC
  channel I've had a good experience. I get a response quickly and
  without snark. Git by contrast, well, let's just say I'd rather be
  affiliated with the Mercurial crowd.</li>
<li>Future potential. Git is a content addressable key-value store with a
  version control system bolted on top. Mercurial is designed to be a
  version control system. Furthermore, Mercurial's code base is much
  easier to hack on than Git's. While Git has largely maintained feature
  parity in the last few years, Mercurial has grown new features. I see
  Mercurial evolving faster than Git and in ways Git cannot.</li>
</ul>
<p>It's worth calling out the major detractors for each.</p>
<p>I think Git's major weakness is its lack of extensibility and inability
to evolve (at least currently). Git will need to grow a better
extensibility model with better abstractions to compete with Mercurial
on new features. Or, the Git community will need to be receptive to
experimental features living in the core. All of this will require
some major API breakage. Unfortunately, I see little evidence this will
occur. I'm unable to find a <em>vision</em> document for the future of Git, a
branch with major new features, or interesting threads on the mailing
list. I tried to ask in their IRC channel and got crickets.</p>
<p>I think Mercurial's greatest weakness is lack of developer mindshare.
Git and GitHub are where it's at. This is huge, especially for projects
wanting collaboration.</p>
<p>Of all those points, I want to stress the extensibility and future
potential of Mercurial. If hacking your tools to maximize potential
and awesomeness is your game, Mercurial wins. End of debate. However,
if you don't want to harness these advantages, then I think Git and
Mercurial are mostly on equal footing. But given the rate of
development in the Mercurial project and relative stagnation of Git
(I can't name a major new Git feature in years), I wouldn't be
surprised if Mercurial's feature set obviously overtakes Git's in
the next year or two. Mind share will of course take longer and will
likely depend on what hosting sites like GitHub and Bitbucket do
(I wouldn't be surprised if GitHub rebranded as <em>CodeHub</em> or
something some day). Time will tell.</p>
<h2>Extending case study</h2>
<p><em>I have removed the case study that appeared in the original article
because as Mike Hommey observed in the comments, it wasn't a totally
accurate comparison. I don't believe the case study significantly added
much to the post, so I likely won't write a new one.</em></p>
<h2>Conclusion</h2>
<p>From where I started with Mercurial, I never thought I'd say this. But
here it goes: I like Mercurial.</p>
<p>I started warming up when it became faster and more robust in recent
versions in the last few years. When I learned about its flexibility and
the fundamentals of the project and thus its future potential, I became
a true fan.</p>
<p>It's easy to not like Mercurial if you are a new user coming
from Git and are forced to use a new tool. But, once you take the time to
properly configure it and appreciate it for what it is and what it
can be, Mercurial is easy to like.</p>
<p>I think Mercurial and Git are both fine version control systems. I would
happily use either one for a new project. If the social aspects of
development (including encouraging new contributors) were important to
me, I would likely select Git and GitHub. But, if I wanted something
just for me or I was a large project looking for a system that scales
and is flexible or was looking to the future, I'd go with Mercurial.</p>
<p>Mercurial is a rising star in the version control world. It's getting
faster and better and enabling others to more easily innovate through
powerful extensions. The future is bright for this tool.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Mozilla Automation Load Over Time]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/05/06/mozilla-automation-load-over-time" />
    <id>http://gregoryszorc.com/blog/2013/05/06/mozilla-automation-load-over-time</id>
    <updated>2013-05-06T11:45:00Z</updated>
    <published>2013-05-06T11:45:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Mozilla Automation Load Over Time]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/05/06/mozilla-automation-load-over-time"><![CDATA[<p><a href="/images/mozilla-automation-load-1.png">This chart</a> plots per-month sums
of total time of jobs in Mozilla's automation in days. The line running
through it is a best fit linear regression.</p>
<p>The raw data is <a href="https://gist.github.com/indygreg/5527091">available</a>.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[SQLite.jsm - SQLite Done Betterer]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/04/14/sqlite.jsm---sqlite-done-betterer" />
    <id>http://gregoryszorc.com/blog/2013/04/14/sqlite.jsm---sqlite-done-betterer</id>
    <updated>2013-04-14T23:55:00Z</updated>
    <published>2013-04-14T23:55:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[SQLite.jsm - SQLite Done Betterer]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/04/14/sqlite.jsm---sqlite-done-betterer"><![CDATA[<p>Did you know there is now a better way to interact with SQLite from
JavaScript in Firefox? It's called
<a href="https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Sqlite.jsm">SQLite.jsm</a>
and it's available in Firefox 20 and later.</p>
<p>SQLite.jsm is an abstraction around the low-level Storage APIs that you
would have used before. However, it eliminates most of the footguns and
makes it easier to write code that doesn't jank the browser and is less
prone to memory leaks. It even has an API to free as much memory as
possible from the current connection!</p>
<p>If you currently use SQLite via Storage, I highly recommend taking a
look at SQLite.jsm - especially if you are using synchronous APIs.</p>
<p>If you are investigating SQLite for the storage needs of your add-on or
browser feature, please keep in mind that SQLite can incur lots of
filesystem I/O and may run slowly on old machines (especially with
magnetic hard drives) and especially with its default configuration.
You may be interested in low-level file I/O using
<a href="https://developer.mozilla.org/en-US/docs/JavaScript_OS.File">OS.File</a>
instead.</p>
<p>If you insist on using SQLite, please educate yourself on and then
seriously consider using
<a href="https://www.sqlite.org/wal.html">Write-Ahead Logging</a> mode on your
database. Some detailed discussion on SQLite behavior as it pertains to
Firefox can be found in <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=830492">bug 830492</a>.
I hope to eventually incorporate more <em>sane by default</em> connection
options into SQLite.jsm to make it easier for add-ons and browser
features to have the least-impactful behavior by default (e.g. enable
WAL by default). Until then, please, please, please research
<a href="https://www.sqlite.org/pragma.html">PRAGMA</a> statements to optimize
how your SQLite database runs so it has as little performance overhead
as possible. Also consider dropping into an IRC channel on
irc.mozilla.org and asking for advice from one of the many who have
fallen into SQLite's many performance pitfalls (including me).</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Making hg-git Faster]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/04/14/making-hg-git-faster" />
    <id>http://gregoryszorc.com/blog/2013/04/14/making-hg-git-faster</id>
    <updated>2013-04-14T21:45:00Z</updated>
    <published>2013-04-14T21:45:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Git" />
    <summary type="html"><![CDATA[Making hg-git Faster]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/04/14/making-hg-git-faster"><![CDATA[<p>When enterprising individuals at Mozilla
<a href="http://bluishcoder.co.nz/2011/02/10/git-conversion-of-mozilla-central.html">started maintaining</a>
a Git mirror of Firefox's main source repository (hosted in Mercurial),
they ran into a significant problem: conversion was slow. The initial
conversion apparently took over 6 days and used a lot of memory.
Furthermore, each subsequent commit took many seconds, even on modern
hardware. This meant that the they could only maintain a Git mirror of
a few project branches and that updates would be slow. Furthermore,
the slowness of the conversion significantly discouraged people
from using the tool locally as part of regular development.</p>
<p>I thought this was unacceptable. I wanted to enable people to use
their tool of choice (Git) to develop Firefox. So, I did what annoyed
engineers do when confronted with an itch: I scratched it.</p>
<h2>Diagnosing the Problem</h2>
<p>When I started tackling this problem, I had little knowledge of the
problem space other than the problem statement: <em>converting from
Mercurial to Git is prohibitively slow</em> and that the slow tool was
<a href="http://hg-git.github.io/">hg-git</a>. My challenge was thus to make
hg-git faster.</p>
<p>When confronted with a performance problem, one of the first things you
do is identify the source of the bad performance. Then, you need to
acertain whether that is something you have the ability to change.</p>
<p>This often starts by answering some high-level questions then drilling
down into more detail as necessary. For a long-running system tool like
hg-git, I start with the <em>top test</em>: how much CPU, memory, and I/O is
the process utilizing?</p>
<p>In the case of hg-git, we were CPU bound. The Python process was
consistently pegging a single CPU core while periodically incurring I/O
(but not nearly enough to saturate a magnetic disk). This told me a few
things. First, I should look for bottlenecks inside Python. Second, I
should investigate whether parallel execution would be possible. The
latter is especially important these days because the trend in
processors is towards more cores rather than higher clock speeds. It's
no longer acceptable to let increases in clock speed or cycle efficiency
bail you out: if you want a CPU bound process to run as fast as
possible, it's often necessary to involve all available CPU cores.</p>
<p>Once I diagnosed CPU as the limiting factor, I pulled out the next tool
in the arsenal: a code profiler. I quickly discovered exactly where the
conversion was taking the most CPU time. As feared, it was in the
<em>export Mercurial changeset to Git commit</em> function.
Specifically, profiling had flagged the conversion of Mercurial
manifests to Git trees and blobs. Furthermore, most of the time was
spent in functions in Mercurial itself (Mercurial is implemented in
Python and hg-git calls into it natively) and Dulwich (a pure Python
implementation of Git). So, I was either looking at deficiencies or
Mercurial and/or Dulwich, a bad conversion algorithm in hg-git, or both.
To know which, I would need a better grasp on the internal storage
models of Mercurial and Git.</p>
<h2>Learning about Mercurial's and Git's internal storage models</h2>
<p>To understand why conversion from Mercurial to Git was slow, I needed to
understand how each stored data internally. My hope was that if attained
better understanding I could apply the knowledge to assess the algorithm
hg-git was using and optimize it, hopefully introducing parallel
execution along the way.</p>
<h3>Git's internals</h3>
<p>I already had a fairly good understanding of how Git works internally.
And, it's quite simple really. The <a href="http://git-scm.com/book/en/Git-Internals">Git Internals</a>
chapter of the <em>Pro Git</em> is extremely useful. While I encourage readers
to read all of the <a href="http://git-scm.com/book/en/Git-Internals-Git-Objects">Git Objects</a>
section, the gist is:</p>
<ul>
<li>Git's core storage is a key-value data store. Keys are SHA-1 checksums
  of content. Each entity is storage in a <em>Git object</em>.</li>
<li>A <em>blob</em> is an object holding the raw content of a file.</li>
<li>A <em>tree</em> is an object holding a list of <em>tree entries</em>. Each tree entry
  defines a blob, another tree object, etc. A tree is essentially a
  directory listing.</li>
<li>A <em>commit</em> object holds metadata about an individual Git commit. Each
  commit object refers to a specific <em>tree</em> object.</li>
</ul>
<p>When you introduce a new file that hasn't been seen before, a new <em>blob</em>
is added to storage. That blob is referenced by a <em>tree</em>. When you
update a file, a new <em>tree</em> is created referring to the new <em>blob</em> that
was created.</p>
<p>Things get a little complicated when you consider directories. If you
update the file <em>foo/bar/baz.c</em>, the tree for <em>foo/bar</em> changes (because
the SHA-1 of <em>baz.c</em> changed). And, the SHA-1 for the <em>foo/bar</em> tree
changes, so the <em>bar</em> entry in <em>foo</em>'s tree changes, changing the SHA-1
for the root tree.</p>
<p>That's essentially how Git addresses commits, directories, and files. If
you don't grok this, please, please read the aforementioned page on it -
it may even help you better grok Git!</p>
<h3>Mercurial's internals</h3>
<p>Unlike Git, I didn't really have a clue how Mercurial worked internally.
So, I needed to do some self-education here.</p>
<p>The best resource for Mercurial's storage model I've found is the
<a href="http://hgbook.red-bean.com/read/behind-the-scenes.html">Behind the Scenes</a>
chapter from <em>Mercurial: The Definitive Guide</em>. The gist is:</p>
<ul>
<li>History for an individual file is stored in a <em>filelog</em>. Each
  <em>filelog</em> contains the history of a single file. Each file revision
  has a hash based on the file contents.</li>
<li>The <em>manifest</em> lists every file, its permissions, and its file
  revision for each changeset in the repository.</li>
<li>The <em>changelog</em> contains information about each changeset, including
  the revision of the <em>manifest</em> to use.</li>
<li>Each of these logs contain <em>revisions</em> and you can address an
  individual revision within the log.</li>
</ul>
<p>From a high level, Mercurial's storage model is very similar to Git's.
They both address files by hashing their content. Where Git uses
multiple tree objects to define every file in a commit, Mercurial has a
single manifest containing a flat list. Aside from that, the
differences are mostly in implementation details. These are important,
as we'll soon see.</p>
<h2>Analyzing hg-git's conversion algorithm</h2>
<p>Armed with knowledge of how Git and Mercurial internally store data, I
was ready to analyze how hg-git was performing conversion from Mercurial
to Git. Since profiling revealed it was the <em>convert a single changeset
into Git commit</em> function that was taking all the time, I started there.</p>
<p>In Python (but not the actual Python), the algorithm was essentially:</p>
<div class="pygments_murphy"><pre><span class="k">def</span> <span class="nf">export_changeset_to_git</span><span class="p">(</span><span class="n">changeset</span><span class="p">,</span> <span class="n">git</span><span class="p">,</span> <span class="n">already_converted</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Receives the Mercurial changeset and a handle on a Git object storre.&quot;&quot;&quot;</span>
    <span class="c"># This is an entity that helps us build Git tree objects from</span>
    <span class="c"># paths and blobs. The logic is at</span>
    <span class="c"># https://github.com/jelmer/dulwich/blob/2a8548be3b1fd4a1ae7d0436dce91611112c47c2/dulwich/index.py#L298</span>
    <span class="n">tree_builder</span> <span class="o">=</span> <span class="n">TreeBuilder</span><span class="p">()</span>

    <span class="k">for</span> <span class="nb">file</span> <span class="ow">in</span> <span class="n">changeset</span><span class="o">.</span><span class="n">manifest</span><span class="p">:</span>
        <span class="n">blob_id</span> <span class="o">=</span> <span class="n">already_converted</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">blob_id</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">blob</span> <span class="o">=</span> <span class="n">Blob</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">data</span><span class="p">())</span>
            <span class="n">git</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">blob</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">blob</span><span class="o">.</span><span class="n">content</span><span class="p">)</span>
            <span class="n">already_converted</span><span class="p">[</span><span class="nb">file</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">blob</span><span class="o">.</span><span class="n">id</span>
            <span class="n">blob_id</span> <span class="o">=</span> <span class="n">blob</span><span class="o">.</span><span class="n">id</span>

        <span class="n">tree_builder</span><span class="o">.</span><span class="n">add_file</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">blob_id</span><span class="p">,</span> <span class="nb">file</span><span class="o">.</span><span class="n">mode</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">tree_builder</span><span class="o">.</span><span class="n">all_trees</span><span class="p">():</span>
        <span class="n">git</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">content</span><span class="p">)</span>

    <span class="n">root_tree</span> <span class="o">=</span> <span class="n">tree_builder</span><span class="o">.</span><span class="n">root_tree</span>

    <span class="c"># And proceed to build the Git commit and insert it.</span>
</pre></div>

<p>On the face of it, this code doesn't seem too bad. If I were writing the
functionality from scratch, I'd likely do something very similar. So,
why is it so slow?</p>
<p>As I mentioned earlier, profiling results had identified Mercurial and
Dulwich as the hot spots. The Mercurial hotspot was in iteration over
the files in the manifest. And the Dulwich offender with Git <em>tree</em>
object construction. By why?</p>
<p>First, it turns out that iterating a manifest the way hg-git was isn't
exactly performant. I never traced all the gory details, but I'm pretty
sure every time it accessed the file context through the change context
there was I/O involved. Not good, especially if you may not need the
information contained if it was already cached!</p>
<p>Second, it turns out that creating Git <em>tree</em> objects in Dulwich is
rather slow. And, the problem is magnified when converting large
repositories - like mozilla-central (Firefox's canonical repository).</p>
<p>So, I was faced with a decision: make Mercurial and/or Dulwich faster or
change hg-git. Since improving these would have benefits outside of
hg-git, I initially went down those roads. However, I eventually
abandonded the effort because of effort involved. And, in the case of
Dulwich, improving things would likely require rewriting some pieces in
C - not something I cared to do nor something that the Dulwich people
would likely accept since Dulwich is all about being a pure Python
implementation of Git! And in hindsight, this was the right call.
Mercurial and Dulwich are fast enough - it's hg-git that was being
suboptimal.</p>
<p>I was faced with two problems: don't mass iterate over manifests and
don't mass generate Git trees. Both were seemingly impossible to avoid
because both are critical to converting a Mercurial changeset to Git.</p>
<p>I thought about this problem for a while. I experimented with numerous
micro benchmarks. I engaged the very helpful Mercurial developers on IRC
(thanks everyone!). And, I eventually arrived at what I think is an
elegant solution.</p>
<p>When I took a step back and looked at the larger problem of exporting
Mercurial changesets to Git, I realized it would be beneficial in terms
of efficiency for the conversion to be more aware of what had occurred
before. Before I came along, hg-git was asking Mercurial for the full
state of each changeset for each changeset conversion. When you think
about it in low-level operations, this is extremely inefficient. Let's
take Git trees as an example.</p>
<p>When you perform a commit, only the trees - and
their parents - that had modified files will change. All the
other trees will be identical across commits. For large repositories (in
terms of files and directories) like mozilla-central, the number of
<em>static</em> trees across small commits is quite significant compared to
changed trees. The overhead of computing all these trees is not
insignificant!</p>
<p>Instead of throwing away all the trees and file context information
between changeset exports, what if I preserved it and reused it for the
next changeset? I think I'm on to something...</p>
<h2>Implementing incremental changeset export</h2>
<p>To minimize the work performed when exporting Mercurial changesets to
Git, I <a href="https://github.com/indygreg/hg-git/commit/aef6eacf86fb08101ea98a7787f3b20dd67287c2">implemented</a>
a standalone class that can emit Mercurial changeset deltas in terms of
Git objects. Essentially, it caches a Git tree representation of a
Mercurial manifest. When you feed a new Mercurial changeset into it, it
asks Mercurial to compare those changesets using the same API used by
<em>hg status</em>. This API is efficient and returns the information I care
about: the paths that changed. Once we have the changed files, we
<em>simply</em> reflect those changes in terms of updating Git trees.</p>
<p>If a file changes or is added, we emit a <em>blob</em>. If a <em>tree</em> changes, we
emit the new <em>tree</em> object. When the consumer has finished writing the
set of new objects to Git, it asks for the SHA-1 of the root tree. (Up
until this point the consumer is not aware of what any of the emitted
objects actually are - just that they likely need to be added to
storage.) It then uses the SHA-1 of the root tree to construct the
commit. Then it moves on to the next changeset.</p>
<p>The impact of this change is significant. On my computer, converting
Mercurial's own Mercurial repository Git went from <strong>21:07</strong> to <strong>8:14</strong>
on my i7-2600k. mozilla-central is even more drastic. The first 200
commits (the first commit was a large dump from CVS) took <strong>8:17</strong>
before and now take <strong>2:32</strong>. I don't have exact numbers from newer
commits, but I do know they were at least twice as slow as the initial
commits and showed an even more drastic speedup.</p>
<p>But I was just getting started.</p>
<p>The initial implementation wasn't very efficient in terms of reducing
tree object calculations. I changed that earlier today when I
<a href="https://groups.google.com/d/msg/hg-git/I5w_FscF6lw/LAc0pw1iilQJ">submitted a patch for consideration</a>
that only calculates tree changes for trees that actually changed. I
also removed some needless sorting on the order of export operations.
This second patch reduced conversion of Mercurial's repository down to
<strong>5:33</strong>. Even more impressive is that <strong>mozilla-central's changesets are
now exporting almost 4x faster</strong> with this patch alone. The first 200
changesets now export in <strong>42s</strong> (down from <strong>2:32</strong> which is down from
<strong>8:17</strong>). This is mostly due to the overhead of reprocessing
non-dirty trees on every export.</p>
<p>And I'm not through.</p>
<p>As part of building the standalone incremental changeset exporter, one
of the goals in the back of my mind was to eventually have things
execute in parallel.</p>
<p>In my <a href="https://github.com/indygreg/hg-git/tree/performance-next">personal development branch</a>
I have a <a href="https://github.com/indygreg/hg-git/commit/e74641284fecc928b0b8f8dcc01ef9b99e09c3cc">patch</a>
to perform Mercurial changeset export on multiple cores. Essentially
hg-git fires up a bunch of worker processes and asks each to export a
consecutive range of changesets. The workers writes new Git objects into
Git and then tells the coordinator process the root tree SHA-1
corresponding to each Mercurial changeset. The coordinator process then
uses these root tree SHA-1's to derive Git commit objects (you can't
create the commit object until you know the SHA-1 of the commit's
parents).</p>
<p>The blob and tree exporting on separate processes makes Mercurial to Git
export scale out to however many cores you feel like throwing at it.
When 32 core machines come around, you can convert using all available
cores and the speedup should roughly be linear with the number of cores.</p>
<p>I'm still working out some kinks in the multiple processes patch
(the <em>multiprocessing</em> module is very difficult to get working on all
platforms and I don't want to break hg-git when it lands). But,
<a href="http://ehsanakhgari.org/">Ehsan Akhgari</a> has been using it to power the
<a href="https://github.com/mozilla/mozilla-central/">GitHub mirror</a> of
mozilla-central for months without issue. (His use of these patches
freed up the CPU required to support conversion of more project branches
on the Git mirror. And, he's still not using the 4x improvement patch I
wrote today - he will shortly - so who knows what improvements will stem
from that.)</p>
<p>With all the patches applied, hg-git now feels like a Ferrari when
exporting Mercurial changesets to Git. Conversion of Mercurial's
repository now takes <strong>1:25</strong> (down from <strong>21:07</strong>). <strong>Conversion of
mozilla-central has gone from 6+ days to about 3 hours!</strong> More
importantly, ongoing conversions feel somewhat snappy now.</p>
<h2>Making Git export even faster</h2>
<p>With the patch today, I'd say optimization of exporting Mercurial
changesets is nearing its limits. There are a few things I could try
that may net another 2 or 3x improvement. But, I think the ~50x
improvement I've already attained (at least for mozilla-central) is
pretty damn good and good enough for most users. (Part of performance
optimization is knowing when is good enough and stopping before you
invest excessive time in the long tail.)</p>
<p>There is one giant refactor that could likely net a significant win for
Git export. However, it requires optimizing for initial export over
recurring incremental export (which is why I have little interest in
it). Incremental export incurs a lot of <em>random</em> I/O accessing Mercurial
filelogs and extracting specific file revisions as they are needed. An
optimal export would iterate over the filelogs and export Git blobs from
each filelog in the sequence they occur in within the filelogs. It would
cache the file node to blob SHA-1. After all blobs are exported, the
mappings would be combined and distributed to all workers. Then, tree
export would occur in parallel largely under the existing model modulo
blob writing. This would minimize overall I/O and work in Mercurial and
would likely be significantly faster. However, it's mostly useful for
initial export and IMO not worth implementing. (It's possible to employ
a variation for incremental export that iterates over filelogs and
exports not-yet-seen revisions. Perhaps I will investigate this some
day.)</p>
<h2>What about converting Git to Mercurial?</h2>
<p>Now that I've tackled Mercurial to Git conversion, it's very tempting to
work magic on the inverse: converting Git commits to Mercurial
changesets. While I haven't looked at this problem in detail, I already
know it will be at least slightly more challenging.</p>
<p>The reason is parallelization. With Mercurial export, I have each child
process reading directly from Mercurial and writing directly to Git.
There are no locks involved. There is just a coordinator that ensures
minimum redundant work among workers. There is some redundant
work, sure. But, the alternative would be lots of locking and/or
exchange of state across processes - not cheap operations! Furthermore,
the writes into Git can occur in any order (since Git is just a
key-value store). The only hard requirement is a child commit must
come after its parent (because you need the parent commit's SHA-1).
And, single-threaded insert of commit objects isn't a big deal because
you can crank through hundreds of them per second (it might even be over
1000/s on my machine).</p>
<p>Mercurial's storage implementation does not afford me the same
<em>carelessness</em> with regards to writing into storage. Since Mercurial
uses shared files for individual file and manifest history, we have
a contention problem. We <em>could</em> lock files when writing to them.
However, these files (<em>revlogs</em> in Mercurial speak) also use
transparent delta compression. You get the best performance/compression
when changes are written in the order they actually occured in (at
least in the typical case).</p>
<p>To optimally write to Mercurial you need to order inserts. This means
parallel reads from Git (in separate worker processes) would be very
difficult to implement. Doable, sure, but you're looking at a lot of
transferred state and ordering. This likely involves a lot more memory
and CPU usage.</p>
<p>The best idea I've come up with so far is a single process
that reads off Git commits and iterates trees. It hashes the paths of
seen files to a consistent worker process which then pulls the blob from
Git's storage and inserts it into the filelog. You don't need to lock
filelogs because only one worker owns a specific path. Workers report
the blob's corresponding file node to another process which then
assembles manifests, writes manifests in order, and finally creates
and writes changesets. Unfortunately, the worker processes are just
doing blob I/O. There is no parallel processing of Git tree calculation
or Mercurial manifests. Given this was a significant source of slowness
exporting <em>to</em> Git, I worry the inverse will be true. Although, the
problem with Git was tree <em>creation</em> and it was due to the volume. Since
there is only 1 manifest per changeset, perhaps it won't be as bad.</p>
<p>While I've brainstormed a solution, I have no concrete plans to work on
Git to Mercurial conversion. The impetus for me working on Mercurial to
Git speedups was that I and a number of other Mozilla people were
personally impacted. If the same is true for Git to Mercurial slowness,
I could invest a few hours the next time I'm sick and bored over the
weekend.</p>
<h2>Conclusion</h2>
<p>Converting Mercurial repositories to Git with hg-git is now
significantly faster. If you thought it was too slow before, grab the
latest code (from either the official repository or my personal branch)
and enjoy.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Bulk Analysis of Mozilla's Build and Test Data]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/04/01/bulk-analysis-of-mozilla's-build-and-test-data" />
    <id>http://gregoryszorc.com/blog/2013/04/01/bulk-analysis-of-mozilla's-build-and-test-data</id>
    <updated>2013-04-01T13:12:00Z</updated>
    <published>2013-04-01T13:12:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <category scheme="http://gregoryszorc.com/blog" term="Firefox" />
    <summary type="html"><![CDATA[Bulk Analysis of Mozilla's Build and Test Data]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/04/01/bulk-analysis-of-mozilla's-build-and-test-data"><![CDATA[<p>When you push code changes to Firefox and other similar Mozilla
projects, a flood of automated jobs is triggered on Mozilla's
infrastructure. It works like any other continuous integration
system. First you build, then you run tests, etc. What sets it
apart from other continuous integration systems is the size:
Mozilla runs thousands of jobs per week and the combined output
sums into the tens of gigabytes.</p>
<p>Most of the data from Mozilla's continuous integration is
available on public servers, notably ftp.mozilla.org. This includes
compiled binaries, logs, etc.</p>
<p>While there are tools that can sift through this mountain of data
(like <a href="https://tbpl.mozilla.org">TBPL</a>), they don't allow ad-hoc
queries over the raw data. Furthermore, these tools are very
function-specific and there are many data views they don't expose.
This <em>missing</em> data has always bothered me because, well, there
are cool and useful things I'd like to do with this data.</p>
<p>This itch has been bothering me for well over a year. The
persistent burning sensation coupled with rain over the weekend
caused me to scratch it.</p>
<p>The <a href="https://github.com/indygreg/mozilla-build-analyzer">product of my weekend labor</a>
is a system facilitating bulk storage and analysis of Mozilla's
build data. While it's currently very alpha, it's already showing
promise for more throrough data analysis.</p>
<p>Essentially, the tool works by collecting the dumps of all the jobs
executed on Mozilla's infrastructure. It can optionally supplement
this with the raw logs from those jobs. Then, it combs through this
data, extracts useful bits, and stores them. Once the initial
fetching has completed, you simply need to re-"parse" the data set
into useful data. And, since all data is stored locally, the
performance of this is not bound by Internet bandwidth. In practice,
this means that you can obtain a new metric faster than would have
been required before. The downside is you will likely be storing
gigabytes of raw data locally. But, disks are cheap. And, you have
control over what gets pulled in, so you can limit it to what you
need.</p>
<p>Please note the project is very alpha and is only currently serving
my personal interests. However, I know there is talk about <em>TBPL2</em>
and what I have built could evolve into the data store for the next
generation TBPL tool. Also, most of the work so far has centered on
data import. There is tons of analysis code waiting to be written.</p>
<p>If you are interested in improving the tool, please file a GitHub
pull request.</p>
<p>I hope to soon blog about useful information I've obtained through this
tool.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Omnipresent mach]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/03/03/omnipresent-mach" />
    <id>http://gregoryszorc.com/blog/2013/03/03/omnipresent-mach</id>
    <updated>2013-03-03T12:30:00Z</updated>
    <published>2013-03-03T12:30:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <category scheme="http://gregoryszorc.com/blog" term="Firefox" />
    <category scheme="http://gregoryszorc.com/blog" term="mach" />
    <summary type="html"><![CDATA[Omnipresent mach]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/03/03/omnipresent-mach"><![CDATA[<p>Matt Brubeck recently landed an awesome patch for mach in
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=840588">bug 840588</a>:
it allows mach to be used by any directory. I'm calling it
<em>omnipresent mach</em>.</p>
<p>Essentially, Matt changed the <em>mach</em> driver (the script in the root
directory of mozilla-central) so instead of having it look in hard-coded
relative paths for all its code, it walks up the directory tree and
looks for signs of the source tree or the object directory.</p>
<p>What this all means is that if you have the <em>mach</em> script installed in
your $PATH and you just type <em>mach</em> in your shell from within any source
directory or object directory, <em>mach</em> should just work. So, no more
typing <em>./mach</em>: just copy <em>mach</em> to <em>~/bin</em>, <em>/usr/local/bin</em> or some
other directory on your $PATH and you should just be able to type
<em>mach</em>.</p>
<p>Unfortunately, there are bound to be bugs here. Since <em>mach</em>
traditionally was only executed with the current working directory as
the top source directory, some commands are not prepared to handle a
variable current working directory. Some commands will likely get
confused when it comes resolving relative paths, etc. If you find
an issue, please report it! A temporary workaround is to just invoke
mach from the top source directory like you've always been doing.</p>
<p>If you enjoy the feature, thank Matt: this was completely his idea and
he saw it through from conception to implementation.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[moz.build Files and the Firefox Build System]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/02/28/moz.build-files-and-the-firefox-build-system" />
    <id>http://gregoryszorc.com/blog/2013/02/28/moz.build-files-and-the-firefox-build-system</id>
    <updated>2013-02-28T19:45:00Z</updated>
    <published>2013-02-28T19:45:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <category scheme="http://gregoryszorc.com/blog" term="Firefox" />
    <category scheme="http://gregoryszorc.com/blog" term="build system" />
    <summary type="html"><![CDATA[moz.build Files and the Firefox Build System]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/02/28/moz.build-files-and-the-firefox-build-system"><![CDATA[<p>The next time you update mozilla-central you may notice some significant
changes with the build system. That's because this morning we finally
landed the start of a massive overhaul of the build system! There are
many end goals to this effort. The important ones for most will be
faster build times and a build system that is friendlier to make changes
to.</p>
<h2>Introducing moz.build Files</h2>
<p>If you look in the tree, you'll notice that nearly every directory
now has a <em>moz.build</em> file.</p>
<p><em>moz.build</em> files are what we are using to define the build system. Think of
them each as a descriptor that describes how to build its own part of the
tree. An individual <em>moz.build</em> file will contain the C++ sources to
compile, the headers to export, the tests to run, etc. Eventually.
Currently, they are limited to directory traversal information.</p>
<p><em>moz.build</em> files essentially add a level of indirection between the
build system definition and how the tree is actually built. Before
<em>moz.build</em> files, the same metadata we are now capturing in <em>moz.build</em>
files (or plan to capture) was captured in <em>Makefile.in</em> files. We
performed simple variable substitution on these <em>Makefile.in</em> files to
produce <em>Makefile</em> files in the object directory. These <em>Makefile</em> files
were used by GNU Make (or Pymake on Windows) to build the tree.</p>
<p>As I outlined in <a href="/blog/2012/06/25/improving-mozilla's-build-system/">Improving Mozilla's Build System</a>,
<em>Makefile.in</em> are suboptimal for a number of reasons. The important
bit is they essentially tie us to the use of make (recursive or otherwise).
We are very interested in supporting modern build systems such as Tup
(the theory being they will build the tree faster).</p>
<p>Enter <em>moz.build</em> files. Storing our build configuration in
<em>moz.build</em> files allows us to decouple the definition of the build
system from the tool used to build it.</p>
<h2>How moz.build Files Work</h2>
<p>At the tail end of <em>configure</em>, the build system invokes the
<em>config.status</em> script in the object directory. The role of
<em>config.status</em> is to combine the information collected during
<em>configure</em> with the build configuration obtained from <em>moz.build</em> files
and take the necessary actions to ensure the build backend (make) can
build the tree.</p>
<p>Before today, <em>config.status</em> essentially iterated over the source tree
and converted <em>Makefile.in</em> files to <em>Makefile</em> in the object directory.
Things are now slightly more complicated with <em>moz.build</em> files.</p>
<p>When <em>config.status</em> runs, it starts with the
<a href="https://hg.mozilla.org/mozilla-central/file/87de54667483/moz.build">root moz.build</a>
from the source tree. It feeds this file into a Python interpreter. It
then looks for special variables like <em>DIRS</em> and <em>PARALLEL_DIRS</em> to determine
which directories contain additional <em>moz.build</em> files. It then descends
into all the referenced directories, reading their <em>moz.build</em> files.
While this is happening, we are converting the results of each
<em>moz.build</em> file execution into <em>backend.mk</em> files that make knows how
to build. It also performs the <em>Makefile.in</em> to <em>Makefile</em> conversion
like it always has. When the whole process has finished, the object
directory contains a bunch of <em>Makefile</em> and <em>backend.mk</em> files. make
runs like it always has. The only real difference is some variables are
coming from the <em>moz.build</em>-derived <em>backend.mk</em> files instead of
<em>Makefile</em>.</p>
<p>This is just a brief overview, of course. If you want to know more,
see the code in <em>/python/mozbuild/mozbuild/frontend</em> and
<em>/python/mozbuild/mozbuild/backend</em>.</p>
<h2>Build System Future</h2>
<p>With the introduction of <em>moz.build</em> files, the intent is to <strong>eventually
completely eliminate Makefile.in and have all the build definition live
in moz.build files.</strong></p>
<p>Doing this all at once would have been next to impossible. So, we
decided to eliminate <em>Makefile.in</em> gradually. The first step is what
landed today: essentially moving <em>DIRS</em> variables out of <em>Makefile.in</em>
and into <em>moz.build</em> files. Next, we will be eliminating empty
<em>Makefile.in</em> (<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=844635">bug 844635</a>)
and will be moving more parts of the build definition from <em>Makefile.in</em>
to <em>moz.build</em> files. The next part to move over will likely be IDLs
(<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=818246">bug 818246</a>).
After that, it may be exported files (<em>EXPORTS</em> in <em>Makefile.in</em>
parlance). And repeat until we have no more <em>Makefile.in</em> in the tree.</p>
<p>Each migration of build definition data to <em>moz.build</em> files will likely
occur in two phases:</p>
<ol>
<li>A largely mechanical move of the variables from <em>Makefile.in</em> to
   <em>moz.build</em>.</li>
<li>Better build backend integration resulting from the move.</li>
</ol>
<p>In phase #1, we will essentially cut and paste variable assignments to
<em>moz.build</em> files. make will read the same variables it does today and
perform the same actions. The only difference is the values in these
variables will be defined in <em>moz.build</em> files.</p>
<p>In phase #2, we will leverage the fact that our build definition now has
an API. We will change our existing make backend to be more efficient.
For example, we should soon be able to compile IDLs and copy exported
headers without make traversing through the directory tree at build time.
We will be able to do this because the <em>moz.build</em> traversal at
pre-build time sees data from all <em>moz.build</em> files and with this
<em>complete world view</em> is able to produce more optimal make files than
what you would get if you recursed into multiple directories. In short:
it will make the build faster.</p>
<p>Once we have a sufficient portion of the build definition moved to
<em>moz.build</em> files we will be able to experiment with new build backends
(like Tup), look into automatic Visual Studio project generation, and
more easily experiment with different ways of building (such as
precompiled headers, fewer compiler process invocations, etc). These
should all contribute to faster build times.</p>
<h2>Frequently Asked Questions</h2>
<h4>What impact will I see from this change?</h4>
<p>If you never touched <em>Makefile.in</em> files in the tree, you should not
notice anything different about how the tree builds or how the build
system works. You should have nothing to fear.</p>
<p>The most obvious changes to the source tree are:</p>
<ol>
<li>There is a <em>moz.build</em> file in almost every directory now.</li>
<li>The variables related to directory traversal (those containing <em>DIRS</em>
   in their name) are now defined in <em>moz.build</em> files instead of
   <em>Makefile.in</em>.</li>
<li>If your <em>Makefile.in</em> contains a variable that has been moved to
   <em>moz.build</em> files, make will spew an error when processing that file
   and the build will fail.</li>
</ol>
<h4>Will this change how I build?</h4>
<p>It shouldn't. You should build the tree just like you always have. Most
of you won't notice any differences.</p>
<p>If you see something weird, speak up in #build or file a bug if you are
really confident it is wrong.</p>
<h4>What are the risks to this change?</h4>
<p>The migration of variables from <em>Makefile.in</em> to <em>moz.build</em> files is
largely mechanical and significant portions are done manually. This can
be a mind-numbing and tedious process. Not helping things is the fact
that Splinter's review interface for these kinds of patches is hard to
read.</p>
<p>This all means that there is a non-trivial risk for <em>transcription</em>
errors. All it takes is an inverted conditional block and all of a
sudden large parts of the tree are no longer built, for example.</p>
<p>We have established <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=846425">bug 846825</a>
to investigate any oddities from the initial transfer. Developers are
encouraged to help with the effort. Please spot check that your
directories are still being built, tests run, etc. Pay special attention
to changes made in the last 4 months as these parts of <em>Makefile.in</em>
would have been bit rotted and more prone to data loss.</p>
<p>Parts of the tree not enabled in standard configurations are more prone
to breakage due to less testing. i.e. build configurations not captured
by TBPL have a higher chance of breaking.</p>
<h4>Will this make the tree build faster?</h4>
<p>Not yet. But eventually it will. This initial landing paves the
groundwork to making the tree build faster (see the <em>Future</em> section
above).</p>
<h4>I see a lot of empty moz.build files!</h4>
<p>Yes. Sorry about that. The good news is they shouldn't be empty for
long. As things move from <em>Makefile.in</em> to <em>moz.build</em> we'll see fewer
and fewer empty <em>moz.build</em> files. We'll also see fewer and fewer
<em>Makefile.in</em> files once we start deleting empty <em>Makefile.in</em>.</p>
<p>If you want to know why we must have empty files, it's mainly for
validation. If we allowed <em>moz.build</em> files to be optional, how would
you detect a typo in a directory name? Directory exists? What if that
directory exists but isn't supposed to have a <em>moz.build</em> file?</p>
<h4>You bitrotted my patches!</h4>
<p>Yes. I'm sorry. The transition period to <em>moz.build</em> files could be a
little messy. There will be lots of changes to <em>Makefile.in</em> and
<em>moz.build</em> files and lots of chances for bit rot. Uplifts could be
especially nasty. (Although I don't believe many uplifts involve
significant changes to the build configuration.)</p>
<p>This all means there is a strong incentive for us to complete the
transition as quickly as possible.</p>
<h4>Can I help with the transition to moz.build files?</h4>
<p>Yes!</p>
<p>The transition is largely mechanical (at least phase #1). If you are
interested in moving a variable or set of variables, hop in #build on
IRC and speak up!</p>
<h4>You said moz.build files are actually Python files?!</h4>
<p>Yes they are! However, they are executed in a very tightly controlled
sandbox. You can't import modules, open files, etc. UPPERCASE variable
names are reserved and only a few functions are exposed. If you attempt
to assign to an unknown UPPERCASE variable or assign an invalid value,
an error will occur. This is already much better than Makefile because
we can now detect errors earlier in the build process (rather than 15
minutes into a build).</p>
<h4>What variables and functions are available in moz.build files?</h4>
<p>If you run |./mach mozbuild-reference| you will see a print-out of
all the variables, functions, and symbols that are exposed to the Python
sandbox that moz.build files execute in. There are even tests that will
fail the build if the sandbox contains symbols not in this output!</p>
<p>The output should be valid reSTructuredText (in case you want to convert
to HTML for reading in your browser).</p>
<h4>What if a moz.build file contains an error?</h4>
<p>The build will break.</p>
<p>A lot of work has gone into making the output of moz.build errors human
friendly and actionable. If you do something wrong, it won't just
complain: it will tell you how to fix it!</p>
<h4>Besides build times, how else will this improve the build system?</h4>
<p>There are several ways!</p>
<p>As mentioned above, moz.build are more strict about what data is allowed
to be defined. If you assign to an UPPERCASE variable, that variable
must be known to the sandbox or else the assignment will error. This
means that if you assign to an UPPERCASE variable, you know it has a
side-effect. No more cargo culting of old, meaningless variables!</p>
<p>To change the behavior of moz.build files (add new variables or
functions, change how makefile generation works, etc) will require
changes to the code in /python/mozbuild. This code belongs squarely to
the build module and requires appropriate review. A problem with
Makefiles is that they have lots of foot guns by default and its easy
for self-inflicted wounds to land in the tree without explicit build
peer review. This problem largely goes away with moz.build files because
the sandbox takes away all of make's foot guns.</p>
<p>The output of a moz.build execution is essentially a static data
structure. It's easy to validate them for conformance. If we discover
bad practices in our build definition, we can centrally add tests for
them and enforce best practices.</p>
<p>We will also see user experience wins by moving data to moz.build files.
Take mochitests for an example. We currently have several flavors
(plain, browser, chrome, etc). Sometimes you cannot distinguish the
flavor by the filename alone. With moz.build files, it will be easier to
answer questions like "what mochitest flavor is this file?" mach could
hook into this so you can type |mach mochitest path/to/file.html|
instead of |mach mochitest-plain path/to/file.html|. Even better, you
should just be able to type |mach path/to/test.html| and mach knows from
the build definition that path/to/test.html is a plain mochitest file
and assumes you want to run it. There are dozens of small development
workflow wins to be gained here!</p>
<h4>If I change a moz.build file, what happens?</h4>
<p>If you change a moz.build file, then make should detect that it
has changed and it will update the dynamically generated <em>backend.mk</em>
file and reinvoke the requested build action. This should all happen
automatically (just like <em>Makefile.in</em> to <em>Makefile</em> conversion works
automatically).</p>
<h4>My build seems to pause for a few seconds before starting!</h4>
<p>A change to <em>any</em> moz.build file will cause a full traversal of the
entire moz.build tree. On modern machines, this should only take 1-3
seconds. If your source tree is not in the page cache (and you need
to load moz.build files from disk) or if you are on older hardware, this
could be a little slower.</p>
<p>This is an unfortunate side-effect of having a whole world view of the
build definition. The build delay incurred by these full scans should
eventually be cancelled out by build backend optimizations resulting
from having this whole world view, however.</p>
<p>The good news is this full scan should only occur if a mozbuild file
changes. And, if you are performing make recursion, it should only
happen once (not in every directory). If you notice multiple moz.build
scanning-related pauses during builds, please file a bug in Core ::
Build Config!</p>
<p>Finally, we are performing the reads on a single thread currently. We
can throw more cores at the task if someone codes up a patch.</p>
<h4>What happened to allmakefiles.sh?</h4>
<p>It has been sacked. allmakefiles.sh was an optimization to perform all
the Makefile.in to Makefile conversion in one go. The directory
traversal performed by moz.build reading effectively replaces the role
of allmakefiles.sh. Not only that, but the moz.build build definition is
always up to date! allmakefiles.sh was typically out of sync with
reality and was a burden to maintain.</p>
<h4>Did we just invent our own build system?</h4>
<p>Kinda. We invented a generic Python sandboxing infrastructure. Then we
hooked up code to populate it with variables from our build system and
told it how to perform file traversal by reading specific variables set
during file execution. Then we hooked up code for taking the evaluated
results of all those sandboxes and convert them into make files.</p>
<p>Conceptually, what we invented is like GYP but with a different config
file format. We have dabbled with the idea of converting the parsed
build definition into GYP classes and then leveraging GYP to produce
Makefiles, Ninja files, Visual Studio Projects, etc. This would an
interesting experiment!</p>
<p>If you want to call it a build system, call it a build system. However,
it is currently tightly coupled to Mozilla's needs, so you can't just
use it anywhere. The concept might be worth exploring, however.</p>
<h4>Is there anything else you'd like to share?</h4>
<p>I think we set the record for most parts in a bug: 61. Although, they
are numbered 1-17, 19-20. Part 18 has 30+ sub-parts using letters from
the English and Greek alphabet for identifiers. Part 61 uses the
infinity symbol as its number. See the
<a href="https://hg.mozilla.org/mozilla-central/pushloghtml?changeset=c65d59d33aa8">pushlog</a>.</p>
<p>Finally, I'd like to thank everyone who helped with this effort. The bug
itself was <em>only</em> 6 months old and had active development off and on for
a lot of it. Ted Mielczarek and Mike Hommey provided invaluable feedback
on the core build system patches. A number of module owners stepped in
to lend eyes to the mechanical conversion of their files. Last but not
least, Ms2ger provided invaluable review aid on many of the patches. The
work was so good that we all agreed that an Ms2ger f+ was good enough
for a build peer rs! If reviewing the patches wasn't enough, Ms2ger
also oversaw the tree closure and merging of the landing. I don't know
how I will repay this debt.</p>
<h4>Any more questions?</h4>
<p>If you have more questions, drop in #build on irc.mozilla.org and ask
away.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Thoughts on Logging - Part 1 - Structured Logging]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2012/12/06/thoughts-on-logging---part-1---structured-logging" />
    <id>http://gregoryszorc.com/blog/2012/12/06/thoughts-on-logging---part-1---structured-logging</id>
    <updated>2012-12-06T21:55:00Z</updated>
    <published>2012-12-06T21:55:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <category scheme="http://gregoryszorc.com/blog" term="logging" />
    <summary type="html"><![CDATA[Thoughts on Logging - Part 1 - Structured Logging]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2012/12/06/thoughts-on-logging---part-1---structured-logging"><![CDATA[<h2>Forward</h2>
<p>For reasons I can't explain, I have a keen interest in computer logging
systems. Perhaps it stems from my frustration that such a
seemingly trivial task can often be quite complicated. Perhaps it's from
the scaling challenges inherent with inevitably needing to analyze
terabytes of logged data. Perhaps it's from my experience designing
highly-available distributed server application and needing to use
logging for real-time monitoring and decision making. Whatever the
root causes, I've always wanted to create a brain dump of my thoughts
on logging. So, here we go!</p>
<h2>Introduction</h2>
<p>Logging. Practically every computer program does it in some form or
another. The standard libraries for many programming languages provide
a logging facility. But, have you ever stopped to think about the side
effects of logging or why you log the way you do?</p>
<p>In this first post, I will briefly define what I consider logging and
will talk about something called <em>structured logging</em>.</p>
<h2>The Definition of Logging</h2>
<p>For the scope of these posts, I will define logging to be:</p>
<pre><code>An emitted stream of distinct messages from a running application
</code></pre>
<p>A <em>message</em> can be pretty much anything. They are often strings. But,
they could be binary data. The transport mechanism is undefined.
Although, most logging systems typically write to a file (eventually).</p>
<p>I should also call out the difference between <em>reading</em>/<em>interpreting</em>
logs and <em>transporting</em> them. When I say <em>reading a log</em>, I'm referring
to a process where an entity (either human or machine) <em>reads</em> the
individual message content and infers something from it. By contrast, a
<em>transporter</em> treats messages as a black box and just shuffles bits
around. <em>Transporters</em> also typically send or store logging messages
somewhere.</p>
<p>It's worth explicitly noting that this definition encompasses both
tradtional <em>print()</em> based logging (writing a line to a file or output)
as well as things like transaction logs or recording events as new rows
in a database.</p>
<h2>The Multiple Use Cases of Logging</h2>
<p>Before I get to some of the interesting aspects of logging, let's
identify <em>some</em> of the use cases of logging (in no particular order):</p>
<ol>
<li>Recording application errors (e.g. exceptions and stack traces)</li>
<li>Low-level information to aid in debugging or human observation</li>
<li>Application monitoring (includes metrics and alerting)</li>
<li>Business analytics (use the logged data to help make decisions)</li>
<li>Security auditing</li>
</ol>
<p>Now that we have the basics out of the way, let's move on to the crux of
this post.</p>
<h2>Logging for Humans or Machines</h2>
<p>I would argue that every log message is intended to be <em>interpreted</em>
by either a human or a machine.</p>
<p>If a log message is only going to be used to help a human debug a system
or casually see what's going on, it's intended for humans. If a log
message is going to be used for machine analysis later (e.g. monitoring,
alerting, business analytics, security auditing, etc), it's intended for
machines.</p>
<p>This is an important distinction. If it isn't clear, please re-read the
prior paragraphs. Now might also be a good time for you to audit the
logs in your life and assign <em>human</em> or <em>machine</em> labels to them.</p>
<h2>The Problem</h2>
<p><strong>The problem with logging as most of us know it is that it is optimized
for human consumption, even if machines are the intended consumer.</strong></p>
<p>At the heart of most logging systems we log a string, a char *, an
array of characters that can easily be read by humans. For example, a
simple web application might produce log files containing lines like:</p>
<pre><code>2012:11:24T17:32:23.3435 INFO gps@mozilla.com successfully logged in
</code></pre>
<p>Human readability is a great feature to have. However, it comes at a
price: more difficult machine consumption.</p>
<p><strong>By optimizing for human consumption, we've introduced a new problem:
log parsing.</strong></p>
<p>In the above example log message, what the program has done is combined
a few distinct fields of data (an event - <em>logged in</em>, the
username, and the time) into a single text string. This is great for
humans glancing at a log file. But that decision now necessitates
downstream machine consumers to <em>parse</em>/<em>decode</em> that text back into its
original, distinct fields.</p>
<p>I call this style of logging <em>destructured</em> or <em>unstructured</em> logging. We
start with distinct fields of data and then <em>destructure</em> them into a
fully free-form or semi-formed text. By doing so, we lose part
of the original data structure and necessitate the need to reconstruct
it (via parsing).</p>
<p>This seems silly to me.</p>
<p>Why are we formatting distinct fields of data into unified strings only
to have them parsed into their original components again? If lossless
and simple round-trip encoding/decoding is your goal, there are much
better ways than freely-formed text! Going <em>to</em> text is easy
(<em>printf()</em> or string concatenation are how it is commonly performed).
Getting back to the original representation is the real problem.</p>
<p>Every persisted log message destined for machines will need to be decoded
to some degree to facilitate analysis. However, by using destructured
text, nearly every program and logging system forces this decoding
problem onto its users by using an encoding that is difficult to code.</p>
<p>Every time you are analyzing a log file containing destructured text you
need to solve the parsing/decoding problem. Every time you write an
<em>awk</em>, <em>grep</em>, <em>sed</em>, <em>perl</em>, etc script, use regular expressions, etc
to scrape logs you are solving this problem. <strong>How much time do you
spend decoding/parsing logs versus actually doing something useful with
the data?</strong> From my personal experience, a lot. And, parsing
destructured text is a very fragile solution. What happens when the
string changes, even by just a little? Does that throw off your
decoder/parser?</p>
<p>Decoding log messages is a hard problem. Furthermore, it's a problem I'd
rather not have.</p>
<h2>Structured Logging to the Rescue</h2>
<p><img alt="What if I told you there's a better way to log" src="/images/morpheus_logging.jpg" /></p>
<p>One of my early professional mentors taught me that one of the best ways
to solve a problem is to change the requirements so that the problem no
longer exists or becomes easier to solve. (If that didn't immediately
click with you, you might want to read it again because I feel it's an
invaluable skill and one that many engineers don't employ).
Applying that lesson here, how do we eliminate the problem of
parsing destructured textual data back into its original fields?  Simple:
we don't emit destructured text! Instead, we emit data that is easily
machine readable, where each individual field is preserved. <strong>This is
called structured logging.</strong></p>
<p>The primary benefit of structured logging is that you eliminate the
parsing problem (or at least you change it to be a solved problem by
using a common or well-defined encoding format). No tedious searching
for data within free-form text and extracting it. Instead, the fields
from the event-producing application are seamlessly preserved and
loaded into downstream machine consumers.</p>
<h3>A Closer Look</h3>
<p>What does structured logging look like? Well, it depends. There is no
standard for structured logging. When I first started writing this post
in June 2011, a Google search for <em>structured logging</em> didn't yield
much. Today, things aren't that much better. Although, there has been
significant activity in the last 15 months. rsyslog has launched
<a href="http://blog.gerhards.net/2012/02/announcing-project-lumberjack.html">project Lumberjack</a>,
which has structured logging as a pillar. There is even someone sitting
10 ft from me at Mozilla's SF office doing structured logging for server
applications (<a href="https://wiki.mozilla.org/Services/Sagrada/Metlog">metlog</a>).</p>
<p>All structured logging systems are different. But, the concepts
are mostly the same.</p>
<p>From the perspective of a log-producing application, a function call to
produce an unstructured message may look something like:</p>
<div class="pygments_murphy"><pre><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">username</span> <span class="o">+</span> <span class="s">&quot; successfully logged in&quot;</span><span class="p">)</span>
</pre></div>

<p>Whereas a call to produce that same message in structured form may look
like:</p>
<div class="pygments_murphy"><pre><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;successful_login&quot;</span><span class="p">,</span> <span class="n">who</span><span class="o">=</span><span class="n">username</span><span class="p">)</span>
</pre></div>

<p>You'll immediately notice that the API retains the original pieces of
data. In this example, we just have the event name (<em>successful_login</em>)
and <em>who</em> (some variable value).</p>
<p>This will look different in every programming language, of course. And,
depending on the structured logging mechanism, the common metadata
produced with each message (e.g. time and log level) may differ. But the
general idea is you preserve the rich data fields as they cross over
into the logging facility rather than <em>casting</em> them to a string.
Behind the scenes, the structured logger retains the fields (the
original structure) and encodes them into something machine readable.</p>
<p>Put another way, structured loggers log objects, not strings.</p>
<p>How objects are encoded again depends on the structured logger
implementation. JSON is a well-understood encoding format. An example
JSON encoding of our example message might look like:</p>
<div class="pygments_murphy"><pre><span class="p">[</span><span class="mf">1354317157.034534</span><span class="p">,</span> <span class="s">&quot;INFO&quot;</span><span class="p">,</span> <span class="s">&quot;sucessful_login&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s">&quot;who&quot;</span><span class="p">:</span> <span class="s">&quot;gps@mozilla.com&quot;</span><span class="p">}]</span>
</pre></div>

<p>That's an array of current time, log level, event name/message type, and
a mapping of the data fields.</p>
<p>Or, you could opt for a more efficient encoding format, such as
protocol buffers (which is binary).</p>
<p>The actual encoding theoretically doesn't really matter as long as it can
easily be decoded back into its original data. A good way to identify this
trait is whether you need to implement a decoder/parser more than once
per programming language or if you need to apply different decoding
mechanisms based on the content of a message. If you do, you probably
don't have a generic enough encoding format.</p>
<p>Going back to implementation details, what about a consumer? In
JavaScript, our JSON structured logger from above might look something
like:</p>
<div class="pygments_murphy"><pre><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">line</span> <span class="nx">of</span> <span class="nx">log</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="p">[</span><span class="nx">time</span><span class="p">,</span> <span class="nx">level</span><span class="p">,</span> <span class="nx">action</span><span class="p">,</span> <span class="nx">fields</span><span class="p">]</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">line</span><span class="p">)</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">action</span> <span class="o">==</span> <span class="s2">&quot;successful_login&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">who</span> <span class="o">=</span> <span class="nx">fields</span><span class="p">.</span><span class="nx">who</span><span class="p">;</span>

    <span class="c1">// Do something interesting.</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">action</span> <span class="o">==</span> <span class="s2">&quot;XXX&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>Compare this with a destructured parser:</p>
<div class="pygments_murphy"><pre><span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">line</span> <span class="nx">of</span> <span class="nx">log</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">line</span><span class="p">.</span><span class="nx">endsWith</span><span class="p">(</span><span class="s2">&quot;successfully logged in&quot;</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// Find username.</span>
    <span class="kd">let</span> <span class="nx">spaceIndex</span> <span class="o">=</span> <span class="nx">line</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">username</span> <span class="o">=</span> <span class="nx">line</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">spaceIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

    <span class="c1">// Do something interesting.</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">line</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(...))</span> <span class="p">{</span>
    <span class="c1">//</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>This example admittedly isn't very complex. But, you can already see
some differences. Notably, it takes 1 line to completely parse <em>any</em>
message using the structured logger. The unstructured text parser
requires multiple lines of code <em>per message type</em>. One of those scales
better than the other.</p>
<p>Before I conclude, it's worth mentioning something about event
names/enumerations. You may notice I gave <em>event name</em> a dedicated
field in my example. This is intentional. In a subsequent post,
I will talk about the importance of event names/enumerations and
schemas. Until then, just assume that having a unique event name is
an important aspect of a well-designed structured logging system.
Hence its inclusion in my examples above.</p>
<h2>Conclusion</h2>
<p>I think the vast majority of application logging is done suboptimally
because it forces a <strong>hard</strong> problem of decoding/parsing onto consumers.
Given that many logs are intended for machines, I think this is a
problem that shouldn't need to exist and the software industry should
rethink its current approach to logging by offering first-class
structured logging facilities and subsequently encouraging their use.</p>
<p>If application logging retained the data behind messages, the problem
of parsing/decoding log messages would largely vanish and we would be
left with the real problem: actually doing something useful with
logged data. That is the point of logging after all, isn't it?</p>
<p>Now, this may sound like I'm waiving my hands a bit. You are right:
structured logging by itself is no silver bullet. There are many ways to
do it suboptimally and to use it when you shouldn't. In subsequent posts
to this series, I will dive deeper into how to properly design a
(structured) logging system. I will also investigate some of the
performance implications associated with different logging mechanisms.
Stay tuned.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Changes to How mach Loads mozconfigs]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2012/12/05/changes-to-how-mach-loads-mozconfigs" />
    <id>http://gregoryszorc.com/blog/2012/12/05/changes-to-how-mach-loads-mozconfigs</id>
    <updated>2012-12-05T10:30:00Z</updated>
    <published>2012-12-05T10:30:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <category scheme="http://gregoryszorc.com/blog" term="Firefox" />
    <summary type="html"><![CDATA[Changes to How mach Loads mozconfigs]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2012/12/05/changes-to-how-mach-loads-mozconfigs"><![CDATA[<p>If you use mach to build Firefox, there is a chance you may run into
some errors from a change that landed on mozilla-central Wednesday.</p>
<p>I reimplemented the mozconfig finding and loading logic in Python and
with a nice shell wrapper that lets us more easily inspect side-effects
of execution. The overall goal is to speed up mozconfig loading (fewer
shell invocations) as well as to have a strong API for interacting with
mozconfigs so we can do things like better validation. As a side effect,
we now have test coverage of mozconfig behavior!</p>
<p>Anyway, because the logic for mozconfig finding and loading is going
through a completely new mechanism, you may notice some weird behavior.
Until a few minutes ago, $topsrcdir wasn't defined in the execution
environment. This is now fixed. I think most complaints stemmed from
this.</p>
<p>Another significant change is that mozconfig shell scripts are now
executed in a shell that has <em>set -e</em>. This means that failing commands
in your mozconfig will now abort execution. Before, execution would have
silently continued unless you checked the exit code in your mozconfig.
I think this is a change for the better, but it may break your
mozconfigs.</p>
<p>If you encounter an issue, please follow the instructions in mach's
output to file a bug. Please attach or link to your mozconfig.</p>]]></content>
  </entry>
</feed>
