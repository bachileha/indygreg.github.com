<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>Gregory Szorc's Digital Home</title>
    <link>http://gregoryszorc.com/blog</link>
    <description>Rambling on</description>
    <pubDate>Fri, 30 Aug 2013 19:23:49 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>Visualizing Mozilla's release infrastructure machine efficiency</title>
      <link>http://gregoryszorc.com/blog/2013/08/30/visualizing-mozilla's-release-infrastructure-machine-efficiency</link>
      <pubDate>Fri, 30 Aug 2013 12:30:00 PDT</pubDate>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2013/08/30/visualizing-mozilla's-release-infrastructure-machine-efficiency</guid>
      <description>Visualizing Mozilla's release infrastructure machine efficiency</description>
      <content:encoded><![CDATA[<p>Have you ever wondered what the machines in Mozilla's automation
infrastructure are doing all the time? I have. So, I decided to create a
visualization of this data. You can find it at
<a href="http://automation-dashboard.paas.allizom.org/">http://automation-dashboard.paas.allizom.org/</a>.</p>
<p>When you start looking at the visualizations, you notice something:
there's a lot of time when machines aren't doing anything! All that
white space between jobs is time machines are not processing jobs. This
is capacity Mozilla is failing to utilize.</p>
<p>While some may say Mozilla's automation infrastructure has a load or
capacity problem, I say it has an efficiency problem. The average
machine in our automation infrastructure is doing work less than 50% of
the time <em>during weekdays</em>. Now, some of this might be VMs that are
powered off (due to low demand). But considering physical machines are
also under-utilized, I'd say it's a global problem.</p>
<p>Oh, and don't get too hung up with a machine-job efficiency metric.
While important, it's only part of the problem. When jobs are running,
they are typically only using a fraction of the CPU available to them.
From data <a href="/blog/2013/07/14/quantifying-mozilla's-automation-efficiency/">now available in mozharness</a>,
we know that many test suites only use 10-15% CPU. If you combine this
with sub-50% machine utilization in terms of jobs, I estimate we're only
utilizing somewhere between 5-10% of available CPU cycles in our automation
infrastructure. We have a magnitude more capacity in the machines we
already have. <strong>We don't have a capacity problem, we have an efficiency
problem.</strong> In my opinion we should throw less time and money at new
hardware and invest in maximizing the return from what we have.</p>]]></content:encoded>
    </item>
    <item>
      <title>Mercurial setup wizard for Firefox development</title>
      <link>http://gregoryszorc.com/blog/2013/07/29/mercurial-setup-wizard-for-firefox-development</link>
      <pubDate>Mon, 29 Jul 2013 17:45:00 PDT</pubDate>
      <category><![CDATA[Mercurial]]></category>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2013/07/29/mercurial-setup-wizard-for-firefox-development</guid>
      <description>Mercurial setup wizard for Firefox development</description>
      <content:encoded><![CDATA[<p>I'm a big fan of tools that encourage and/or enforce the following of
best practices and that help people become more productive.</p>
<p>One of the tools that Firefox developers interact with nearly daily is
Mercurial. As I've observed from coworkers and from community
contributors, many don't have Mercurial configured for optimal
development. For first-time contributors, this can manifest in patch
rejection - an experience that can be embarassing and demotivating. This
is frustrating to me because most issues are easily identifiable and
correctable. And, when addressed, everyone wins.</p>
<p>Anyway, I'm pleased to announce that there is now a configuration wizard
in the Firefox source tree to help with configuring Mercurial. To run it,
just type:</p>
<pre><code>./mach mercurial-setup
</code></pre>
<p>Currently, it's aimed for first-time contributors. So, it's missing
things that more seasoned developers rely on. But you need to start
somewhere, right?</p>
<p>Currently, the tool isn't advertised anywhere other than <em>mach help</em>.
Please run it and report issues in
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=794580">bug 794580</a> or
file a new report. Once things have baked in, I'd like to add some kind
of notification/tips system to mach where it will encourage you to do
things like automatically run <em>mach mercurial-setup</em>. Until then, I
recommend trying to remember to run <em>mach mercurial-setup</em> every few
weeks to ensure your Mercurial environment is up to date and properly
configured.</p>
<p>I'd like to thank Nick Alexander for sharing my enthusiasm for helping
contributors and for taking the time to review this work.</p>]]></content:encoded>
    </item>
    <item>
      <title>Track pushes and train riding with Mercurial</title>
      <link>http://gregoryszorc.com/blog/2013/07/25/track-pushes-and-train-riding-with-mercurial</link>
      <pubDate>Thu, 25 Jul 2013 13:10:00 PDT</pubDate>
      <category><![CDATA[Mercurial]]></category>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2013/07/25/track-pushes-and-train-riding-with-mercurial</guid>
      <description>Track pushes and train riding with Mercurial</description>
      <content:encoded><![CDATA[<p>My <a href="https://hg.mozilla.org/users/gszorc_mozilla.com/hgext-gecko-dev">Mercurial extension for Firefox development</a>
now has an initial implementation of pushlog aggregation and searching.</p>
<p>You first start by synchronizing the pushlog data on Mozilla's servers
with the local client:</p>
<pre><code>hg pushlogsync
</code></pre>
<p>This takes a while the first time you run it because it has to download
all the data. On subsequent runs, it only downloads new data, so it
should be much faster.</p>
<p>Then, you can search for the push history of a changeset:</p>
<div class="pygments_murphy"><pre>$ hg changesetpushes -a b968708558b9
133967:b968708558b9 Bug 839809:  Make counter-increments and list counting that would go past our internal (int32_t) limit keep the counter at its current value rather than wrapping.  r=dholbert

Per CSS WG resolution regarding counter-styles-3, afternoon of 2013-02-05:
http://krijnhoetmer.nl/irc-logs/css/20130205#l-1590
http://lists.w3.org/Archives/Public/www-style/2013Feb/0392.html

Note that this patch depends on signed integer overflow behavior in C++,
which I believe is portable despite being unspecified.
Tree      Date                Username              Build Info
inbound   2013-02-21T18:12:57 dbaron@mozilla.com    https://tbpl.mozilla.org/?tree=Mozilla-Inbound&amp;rev=85b91048c1cd
central   2013-02-22T09:43:12 ryanvm@gmail.com      https://tbpl.mozilla.org/?tree=Mozilla-Central&amp;rev=3a7d4085787e
build     2013-02-22T14:31:42 gszorc@mozilla.com    https://tbpl.mozilla.org/?tree=Build-System&amp;rev=3a7d4085787e
fx-team   2013-02-25T01:04:44 ttaubert@mozilla.com  https://tbpl.mozilla.org/?tree=Fx-Team&amp;rev=31466fd86eb7
graphics  2013-02-25T20:02:57 mwoodrow@mozilla.com  https://tbpl.mozilla.org/?tree=Graphics&amp;rev=dcf53b7140cd
ash       2013-02-26T13:50:41 armenzg@mozilla.com   https://tbpl.mozilla.org/?tree=Ash&amp;rev=201b64ad48d8
services  2013-02-28T09:42:45 Ms2ger@gmail.com      https://tbpl.mozilla.org/?tree=Services-Central&amp;rev=31466fd86eb7
aurora    2013-04-01T13:50:56 bbajaj@mozilla.com    https://tbpl.mozilla.org/?tree=Mozilla-Aurora&amp;rev=60a3f369ccf0
beta      2013-05-13T09:59:38 lsblakk@mozilla.com   https://tbpl.mozilla.org/?tree=Mozilla-Beta&amp;rev=60a3f369ccf0
release   2013-06-17T15:53:19 akeybl@mozilla.com    https://tbpl.mozilla.org/?tree=Mozilla-Release&amp;rev=c54e3363712e
</pre></div>

<p>(The <em>-a</em> argument prints all trees instead of just the release trees).</p>
<p>I'd like to integrate bug tracking into the mix to facilitate
answering questions like <em>when did bug 123456 ride the trains</em>.</p>
<p>I'd also like to integrate release versions and build IDs into the mix.
For example, when I look up a changeset, I want to know the first build
on the Nightly, Aurora, Beta, and Release channels that change was
included in.</p>]]></content:encoded>
    </item>
    <item>
      <title>Mercurial Extension for Gecko Development</title>
      <link>http://gregoryszorc.com/blog/2013/07/22/mercurial-extension-for-gecko-development</link>
      <pubDate>Mon, 22 Jul 2013 10:27:00 PDT</pubDate>
      <category><![CDATA[Mercurial]]></category>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2013/07/22/mercurial-extension-for-gecko-development</guid>
      <description>Mercurial Extension for Gecko Development</description>
      <content:encoded><![CDATA[<p>My weekend was spent hacking on Mercurial extensions. First, I worked on
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=827123">porting the pushlog extension off SQLite</a>.
This will eventually enable Mozilla to move Mercurial hosting off NFS
and should make <a href="https://hg.mozilla.org/">hg.mozilla.org</a> much faster as
a result!</p>
<p>But the main purpose of this blog post is to introduce a new Mercurial
extension I wrote this weekend!</p>
<p>Gecko developers perform a number of common tasks with Mercurial, so I
thought it would be handy to package them up in an extension.</p>
<p>To install the extension:</p>
<pre><code>hg clone https://hg.mozilla.org/users/gszorc_mozilla.com/hgext-gecko-dev
</code></pre>
<p>Then add this extension to your hgrc file (either the global or
per-repository will suffice):</p>
<pre><code>[extensions]
mozext = /path/to/hgext-gecko-dev
</code></pre>
<p>Since I believe tools should be self-documenting, run the following for
usage info:</p>
<pre><code>$ hg help mozext
</code></pre>
<p>Here are some examples:</p>
<div class="pygments_murphy"><pre><span class="c"># Clone mozilla-central into the mc directory.</span>
hg clone central mc
hg clone mc mc

<span class="c"># Create a unified Mercurial repository containing changesets</span>
<span class="c"># from all the release repositories.</span>
hg cloneunified gecko

<span class="c"># Pull changes from the central and inbound repositories.</span>
hg pull central
hg pull inbound

<span class="c"># Update the working tree to the tip of inbound.</span>
hg up inbound/default

<span class="c"># View the tree open/closed status.</span>
hg treestatus

<span class="c"># Show a list of all known trees and their aliases.</span>
hg moztrees

<span class="c"># Open TBPL for the push containing a changeset.</span>
hg tbpl inbound 821e984ef423
hg tbpl inbound inbound/default

<span class="c"># Push the tip of inbound to mozilla-central</span>
hg pushtree -r inbound/default central
</pre></div>

<p>I've only tested this extension with Mercurial 2.6 (which every Mozilla
developer should be running). I'm not willing to support older versions.
Upgrade already!</p>
<p>There are a number of features I'd like to implement:</p>
<ul>
<li><strong>hg importtry</strong> - Automatically import changesets for a Try push into
  the repository.</li>
<li><strong>hg land</strong> - Automatically land patches on an integration tree (like
  inbound). Will handle rebasing automatically.</li>
<li><strong>hg critic</strong> - Perform stlye checking and other analysis on a
  changeset or group of changesets.</li>
<li>Ability to integrate build status into changeset info. This will allow
  things such as <em>pull only the last green changeset</em>. I'd also like a
  <em>build status</em> field to appear in the log output. Unfortunately, I
  believe the latency of the build lookup API is prohibitively high to
  perform the kind of tight integration I'd like.</li>
<li>Move <em>mozautomation</em> Python package into a standalone package or
  integrate already existing code (did I reinvent the wheel?).</li>
<li>Log fetching. Specify a changeset and fetch build/test logs.</li>
<li>Possibly move code into mozilla-central.</li>
<li>Possibly add mach commands for some of this functionality.</li>
</ul>
<p>There's no bug component for this extension (yet). If you find any
issues or wish to add a feature, just email a patch to me at gps@mozilla.com.</p>
<p>Please let me know if you find this useful or if you have any questions.</p>]]></content:encoded>
    </item>
    <item>
      <title>Analysis of Firefox's Build Automation</title>
      <link>http://gregoryszorc.com/blog/2013/07/16/analysis-of-firefox's-build-automation</link>
      <pubDate>Tue, 16 Jul 2013 18:15:00 PDT</pubDate>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2013/07/16/analysis-of-firefox's-build-automation</guid>
      <description>Analysis of Firefox's Build Automation</description>
      <content:encoded><![CDATA[<p>Mozilla operates thousands of machines whose sole role is to build
Firefox (and related applications), run tests, perform static analysis,
etc. This is collectively referred to as the <em>Firefox/Mozilla build
automation</em> or just <em>automation</em>. The output of all this automation
can be seen at <a href="https://tbpl.mozilla.org/">tbpl.mozilla.org</a>.</p>
<p>In this post, I'll give an overview of how all this automation works
followed by a critical analysis identifying what I like and what I
feel should be improved.</p>
<h2>How Firefox automation works</h2>
<p>Let's take a journey through what happens when you push a new revision
of <a href="https://hg.mozilla.org/mozilla-central/">mozilla-central</a> (the main
Firefox repository) to Mozilla's canonical Mercurial server. (For
Mozilla people, this journey is roughly the same regardless of which
automation-enabled project branch you push to.) While Firefox's
automation infrastructure kicks off builds on
<a href="https://tbpl.mozilla.org/">several platforms and operating systems</a>,
for simplicity reasons, I'm going to limit low-level technical details
to our 64-bit Linux builds.</p>
<p>Before I begin, a disclaimer: I'm not a subject expert in much of
what I'm about to say. There are people who spend a magnitude more time
than myself touching the systems I'm about to describe. If I get
something wrong, please contact me and I'll update this post.</p>
<p>Let's begin.</p>
<h3>Buildbot</h3>
<p>The heart of Firefox's build automation is a piece of software called
<a href="http://buildbot.net/">Buildbot</a>. Buildbot is essentially a glorified
job scheduling system. I find the
<a href="http://buildbot.net/#/basics">buildbot basics</a> covers, well, the basics
pretty well. What you need to know is that Mozilla maintains a
<a href="https://hg.mozilla.org/build/buildbot/">buildbot repository</a> that
appears to contain the buildbot core plus basic customization for
Mozilla.</p>
<p>There are buildbot <em>masters</em> and <em>slaves</em>. <em>masters</em> do all
the coordination and scheduling; <em>slaves</em> do all the real work (such as
compiling Firefox). Mozilla operates a handful of masters and a few
thousand slaves.</p>
<p>When you push code to a project branch (like <em>mozilla-central</em>), a
buildbot master sees the push then figures out what needs to happen. For
<em>mozilla-central</em>, the push gets translated to a request to build on
several different platforms. These requests then go to a scheduler
(possibly getting collapsed into a single request). These requests then
get turned into jobs that run on slaves.</p>
<p>This logic mostly lives in the
<a href="https://hg.mozilla.org/build/buildbot-configs/">buildbot-configs repository</a>.
Of particular interest is the
<a href="https://hg.mozilla.org/build/buildbot-configs/file/e8b27b8b7216/mozilla/config.py">config.py</a>
file, which pretty much defines how buildbot is configured at Mozilla -
at a high-level anyway.</p>
<p>When a scheduled job executes, the high-level job request is converted into
low-level actions (or <em>steps</em> in buildbot parlance) that get executed on
slaves. For example, a request to build might clone the source
repository, run client.mk, package the results, etc. This logic lives
in the
<a href="https://hg.mozilla.org/build/buildbotcustom/">buildbotcustom repository</a>.
It's worth highlighting the
<a href="https://hg.mozilla.org/build/buildbotcustom/file/bdcca6f7b6c2/process/factory.py">factory.py</a> file. This file contains the beef of the logic
for converting high-level jobs into actions on slaves. Start at the
<a href="https://hg.mozilla.org/build/buildbotcustom/file/bdcca6f7b6c2/process/factory.py#l379">MozillaBuildFactory class</a>
class to see exactly what goes into performing a build. Then move on to
<a href="https://hg.mozilla.org/build/buildbotcustom/file/bdcca6f7b6c2/process/factory.py#l1338">addDoBuildSteps()</a>,
which contains the command for invoking the actual build system. As you
can see, there's a lot that goes into building besides just invoking the
build system (like most developers do)!</p>
<p>For many automation jobs, there is an additional component that comes
into play: <a href="https://hg.mozilla.org/build/mozharness/">mozharness</a>.
<em>mozharness</em> is relatively new to the Firefox build automation
landscape so you may not be familiar with it. A goal of <em>mozharness</em> is
to largely migrate the low-level logic from <em>buildbotcustom</em> - the logic
that converts a high-level job request into low-level buildbot <em>steps</em>
(typically command invocations) - into a separate, standalone entity
that doesn't depend on buildbot. A goal is to enable developers to run
mozharness locally and run automation jobs just like the official
automation infrastructure does. If you have time, I encourage you to
read the
<a href="https://developer.mozilla.org/en-US/docs/Mozharness_FAQ">mozharness FAQ</a>
to learn more. My understanding is <em>mozharness</em> will eventually power
<strong>all</strong> of the jobs currently defined in <em>buildbotcustom</em>, so I
recommend getting acquainted with <em>mozharness</em>.</p>
<p>In the <em>mozharness</em> world, automation jobs are defined as <em>scripts</em>.
Here's the
<a href="https://hg.mozilla.org/build/mozharness/file/84187194b050/scripts/marionette.py">marionette script</a>.
You just execute a script (with ideally as few arguments as possible)
and <em>mozharness</em> does the rest. In buildbot, instead of having a job
with say 12 steps and this logic for configuring the steps live in
buildbot, buildbot just says <em>run the marionette mozharness script</em>.
Since very little business logic now lives in buildbot, this essentially
reduces buildbot's role to just job scheduling.</p>
<p>And that is essentially how the automation determines what to run. Now
let's talk about the machines automation runs on.</p>
<h3>Machine provisioning</h3>
<p>Earlier, I said Mozilla operates thousands of buildbot slaves. Let's
talk about how those slaves come into existence.</p>
<p>A slave is just a fancy name for a machine, either physical or virtual.
These machines are owned or operated by Mozilla. Mozilla either buys
a physical machine or rents one from a <em>cloud provider</em>, like Amazon
EC2.</p>
<p>For hopefully obvious reasons, it is important for the configuration of
these machines to be consistent. Let's talk about how that is done. Keep
in mind I'm talking about Linux machines. OS X and Windows machines go
through a different procedure.</p>
<p>When a new machine is acquired, it needs an operating system. There is a
<a href="https://hg.mozilla.org/build/puppet/file/6f7b4a33af2c/setup/centos6-kickstart.cfg.erb">kickstart config file</a>
that installs CentOS 6.2. At the end of the base OS flash/install, it
configures Puppet to talk to a central Puppet master. This Puppet
infrastructure is called
<a href="https://wiki.mozilla.org/ReleaseEngineering/PuppetAgain">PuppetAgain</a>
and its files are stored in the
<a href="https://hg.mozilla.org/build/puppet/">puppet repository</a>.</p>
<p>Puppet is let loose on the fresh OS install and eventually the machine
is configured so it is homogenous with other similar machines in the
automation infrastructure. Presumably, Puppet continually polls the
central Puppet master and applies the latest configuration.</p>
<p>Part of the <em>puppetization</em> of this machine involves installing the
buildbot client. The client eventually registers with the buildbot
master and waits for jobs to process.</p>
<p>So, we've described how machines are provisioned as buildbot slaves and
how buildbot jobs are converted to actions/steps/commands to be
performed on slaves. Let's examine a job in more detail.</p>
<h3>Running a build job</h3>
<p>Before I talk about the details of a build job, it's worth mentioning
that nearly everything I described up until this point is largely hidden
from view from most Firefox developers. As far as I know, things like
Puppet logs are hidden from public view. And there shouldn't be anything
terribly wrong with that: the Puppet configs are public, after all.
Unless you are affiliated with Release Engineering or the Automation and
Tools Team (A*Team) or hack on a component that warrants its own piece
of automation, you probably aren't too concerned with how all of this
works.</p>
<p>Anyway, it's finally time to start talking about something almost every
Firefox developer has done: build Firefox from source.</p>
<p>As I mentioned above, code in <em>buildbotcustom</em> (to be replaced by
<em>mozharness</em> someday) is responsible for turning a Firefox build job
into a series of actions/steps/commands to run on a slave. And, lucky
for us, the activity of a slave is captured and saved to text log files!
If you've ever used <a href="https://tbpl.mozilla.org/">TBPL</a>, you've almost
certainly clicked a link to view one of these logs.</p>
<p>In this section, I'll describe the steps performed in
<a href="https://ftp.mozilla.org/pub/mozilla.org/firefox/tinderbox-builds/mozilla-central-linux64/1371941584/mozilla-central-linux64-bm62-build1-build35.txt.gz">this log</a>
from a recent <em>mozilla-central</em> build on a 64-bit Linux machine.
I will be paying particular attention to steps that affect the
build environment (for reasons that will be revealed in my critique
below).</p>
<p>If you load our log of interest next to
<a href="https://hg.mozilla.org/build/buildbotcustom/file/bdcca6f7b6c2/process/factory.py#l764">factory.py</a>
from <em>buildbotcustom</em>, you can start to see how they are related.
You may notice <em>self.addStep()</em> calls in <em>factory.py</em> correspond to
<em>========= Started</em> ... <em>========= Finished</em> sections in the log.
That's no accident: every <em>addStep()</em> call produces a section like
that in the log.</p>
<p>Now let's look at some of those steps in detail.</p>
<p>The job/log contains a number of <em>set property</em> steps. Search for
<em>set props</em> and you'll find them in the log. These steps define named
properties in a hash map buildbot uses to represent the current
configuration/state. Think of these properties as a way for buildbot to
communicate metadata between masters and slaves.</p>
<p>One of the first interesting steps we see is the cloning of the
<a href="https://hg.mozilla.org/build/tools">tools repository</a>. Search for
<em>Started clone build tools</em> and you'll find it. This repository contains
a lot of support tools and scripts used by all parts of automation.
There's lots of useful tools in there!</p>
<p>Skipping over the steps that check whether to clobber the builder or
purge old content from disk, the next build steps relevant to our
interests involve the population of a <em>mock</em> environment.
Search for <em>Started mock-tgt mozilla-centos6-x86_64</em> to find it in the
logs.</p>
<p><a href="https://fedoraproject.org/wiki/Projects/Mock">Mock</a> is a piece of
software that manages <a href="https://en.wikipedia.org/wiki/Chroot">chroots</a>.
It was written by the Fedora project for creating isolated build
environments for software packages. For reasons unknown to me,
Mozilla runs a forked version of mock called
<a href="https://github.com/jhford/mock_mozilla">mock_mozilla</a>.</p>
<p>The build job creates a fresh mock environment on every build. (This is
clearly indicated by the <em>INFO: chroot
(/builds/mock_mozilla/mozilla-centos6-x86_64) unlocked and deleted</em>
line in the log.) Later on, builds are performed inside this mock
environment. This means that every build job is mostly isolated from
both the underlying operating system and all build jobs that came
before.</p>
<p>You can see the creation of the new mock environment by looking for the
<em>mock_mozilla -r mozilla-centos6-x86_64 --init</em> command in the log. This
is using the <em>mozilla-centos6-x86_64</em> configuration file to create the new
environment. This file is managed by Puppet, so you can
<a href="https://hg.mozilla.org/build/puppet/file/6f7b4a33af2c/modules/mockbuild/files/mozilla-centos6-x86_64.cfg">see it</a>
in the <em>puppet</em> repository. The
<a href="https://hg.mozilla.org/build/puppet/file/6f7b4a33af2c/modules/mockbuild/files/mozilla-centos6-x86_64.cfg#l11">setup command</a>
on line 11 is the most important line in this file: it defines what
commands to run to initialize the new mock environment.</p>
<p>Populating the mock environment takes a number of buildbot steps. After
copying a bunch of files into the mock/chroot, the mock environment is
further initialized by installing a number of packages. Search for
<em>Started mock-install</em> in the log. Yum is being used to install a number
of packages required to build Firefox. This package list appears to
come from
<a href="https://hg.mozilla.org/build/buildbot-configs/file/e8b27b8b7216/mozilla/config.py#l208">config.py</a>
in the <em>buildbot-configs</em> repository. These packages are downloaded from
a Yum repository hosted by Mozilla. Altogether, 249 new packages
consuming 821 MB are installed during this step!</p>
<p>After the <em>mock</em> environment is created, the <em>mozharness</em> repository is
removed, re-cloned, and updated to the <em>production</em> branch. After that,
we pull changes from <em>mozilla-central</em> and update the local checkout to
the revision we've been told to build.</p>
<p>If you search for <em>Started got mozconfig</em>, you'll find where the
<em>mozconfig</em> file (the build system configuration file) is acquired.</p>
<p>After that, the
<a href="https://wiki.mozilla.org/ReleaseEngineering/Applications/Tooltool">tooltool</a>
configuration is consulted. Tooltool is essentially a content-addressable
file store: files are stored and retrieved by the hash value of their
content. A manifest file inside <em>mozilla-central</em> defines the set of
files to fetch from tooltool at build time. At this step of the build,
that file is consulted and listed files are downloaded. While the Linux
manifest is currently empty, the
<a href="https://hg.mozilla.org/mozilla-central/file/e7e9726025da/browser/config/tooltool-manifests/macosx64/releng.manifest">OS X tooltool manifest</a>
defines the digest of the Clang archive to use to build the tree.</p>
<p>Since tooltool files are addressed by content (not merely by name), this
means that the same file will be fetched no matter when the build runs.
In other words, behavior is constant as the contents of the tooltool
repository itself change (or at least it should be).</p>
<p>After <em>tooltool</em> contents sync, we finally arrive at the actual build
step. Search for <em>Started compile</em> in the log. The important detail here
is that <em>mock_mozilla</em> is used to build firefox with <em>client.mk</em> inside
the fresh mock/chroot environment.</p>
<p>After building, we move on to other tasks, such as creating a
distributable package, running tests, etc. I'm just going to glance over
them because there's a lot going on and it would take a long time to
explain it all! I encourage you to look at the steps in the log and
learn.</p>
<p>While these steps are going on, the buildbot master is notified that the
build and packaging aspect of the job has completed (sometime before
<em>make check</em> is executed). Upon receiving this success notification, the
buildbot master scheduled derived jobs, notably all the test suites
(reftests, mochitests, xpcshell tests, etc). This scheduling occurs
before <em>make check</em> has completed so overall turnaround time is reduced
as much as possible.</p>
<p>Finally, at the end of the log, the slave/machine is rebooted. At this
point, the job has finished. TBPL colors the <em>B</em> next to the job green
to signal successul completion. The slave waits for its next job from
the buildbot master.</p>
<p>And that is how Firefox is built! I could go into details for all of the
derived test jobs, but I won't, as that would take a lot of effort! I
leave that as an exercise for the reader.</p>
<h2>Analysis</h2>
<p>The Firefox build automation is complex and composed of many pieces.
It's a testament to a lot of people's hard work that it works as well as
it does!</p>
<p>From my experience at a previous job managing large numbers of servers
in a production datacenter, I commend Release Engineering for deploying
Puppet to help ensure the machines performing Firefox's build automation
are in a consistent state. I also like how <em>mock</em> is used to mostly
isolate build jobs from one another. These are both very important to
ensure Firefox is built consistently over time.</p>
<p>The on-going migration of automation logic from <em>buildbotcustom</em> to
<em>mozharness</em> is a fantastic project and I hope it is completed soon.
I hold hope that one day we can integrate <em>mozharness</em> into the local
development workflow (likely transparently through tools like <em>mach</em>)
and local developers can invoke actions using the same code path as the
official automation infrastructure.</p>
<h2>Areas for improvement</h2>
<p>The Firefox build automation largely works well. And I don't mean to
take away from that. However, there are a number of areas where
things could be improved. In this section, I'll talk about some of them.</p>
<p>Before I get into details, let me share an experience I had about a year
ago.</p>
<h3>A tale of modifying the xpcshell test harness</h3>
<p>In April 2012, I was writing a lot of JavaScript testing code and was
frustrated at how difficult it was to share test helper code between
tests. I filed
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=748490">bug 748490</a>
to request a new feature in the JavaScript test harnesses: the ability
to create testing-only JavaScript modules that weren't shipped as part
of Firefox. This would encourage code reuse among tests and make writing
tests easier. I thought it would be a relatively simple feature to
implement!</p>
<p>And, it was. At first. The initial implementation landed two weeks after
I filed the bug (it didn't require too much effort, but I was busy with
others tasks). It landed without incident. Although, nothing was using
it and there was no test coverage. However, my local development started
relying on it and things were working just fine.</p>
<p>When I <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=755196">attempted</a>
to actually land a test that made use of this new feature, it failed
because the new directory for these shared modules
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=755339">wasn't being archived</a>.
Simple enough to fix, right? Wrong. Start reading
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=755339#c4">bug 755339 from comment #4</a>.
It is a trail of agony. I had to uplift my change to all
the major branches. Then, once that was done, <em>buildbotcustom</em> could
be updated. Uplifts were performed on May 24. <em>buildbotcustom</em> was
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=755339#c15">pushed out to production</a>
a week later on May 31. It immediately
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=755339#c16">broke the world</a>.
At the time, philor says it was the worst tree bustage he'd ever seen.
Literally every tree was red. Achievement unlocked. A workaround
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=755339#c17">was quickly devised</a>
on May 31 (after the <em>buildbotcustom</em> change was backed out to restore
working automation) and landed. Again, it had to be uplifted to all the
trees. This patch conflicted when applied on older trees and I
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=755339#c23">accidentally committed a typo</a>
and broke beta, release, and esr in the process. I got an earful for
breaking these trees and lost a lot of <em>street cred</em> with the sheriffs
(who are charged with keeping law and order in the land of the source
trees). The <em>buildbotcustom</em> change
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=757460#c21">finally landed</a>
on June 7 and stuck.</p>
<p>Finally, my initial idea of adding testing-only JavaScript modules had been
implemented and was available for all to use. It only required uplifting
a patch to all project branches, having Release Engineering reconfigure
<em>buildbotcustom</em>, and breaking all the trees in the process. This
experience was truly WTFOMGBBQ. And, the agony above was from adding a
seemingly innocuous feature to a single test harness. Can you imagine
what it's like to add a new test harness to automation?!</p>
<h3>In-tree automation configs different from Release Engineering's</h3>
<p>The above example demonstrates many shortcomings in the current
automation infrastructure. The first one I will talk about is that the
in-tree automation configs (how to perform a specific automation job,
such as run an individual test harness) are almost completely different
from what Release Engineering runs on the official infrastructure!</p>
<p>A year ago, <em>mozilla-central</em> had
<a href="https://hg.mozilla.org/mozilla-central/file/e24391ffbe7e/testing/testsuite-targets.mk">testsuite-targets.mk</a> -
a make file defining targets like <em>xpcshell-tests</em> and
<em>mochitest-plain</em> that allowed developers to run these test suites
locally. Release Engineering had <em>buildbotcustom</em>, which didn't use
<em>testsuite-targets.mk</em> at all. While invoking most test harnesses is
simply a matter of formulating arguments for a Python script, that logic
was duplicated between <em>testsuite-targets</em> and <em>buildbotcustom</em>.</p>
<p>Today, <em>Release Engineering</em> has been porting job invocation code to
<em>mozharness</em>. And, I have been encouraging people to locally run tests
with <em>mach</em>. Initially, mach commands executed make. However, commands
are now bypassing make and calling into the Python test harnesses
natively. This allows more advanced behavior since mach has more control
and insight into the underlying test harness. The downside is mach is
now reinventing logic.</p>
<p>So, we now have 3 or 4 separate implementations for performing many of
our automation jobs. Medium term, you figure Release Engineering
consolidates all the <em>buildbotcustom</em> logic into <em>mozharness</em>,
eliminating 1. I also think it is inevitable that <em>testsuite-targets</em> is
refactored to invoke mach commands or is just removed altogether. But
that still leaves us with 2 independent implementations!</p>
<p><strong>I believe we should work towards consolidating the logic for job
invocation to inside mozilla-central.</strong> The commands developers run
locally should be as similar as possible to what runs on official
automation infrastructure. Any differences introduce potential for
different results. Differences also increase the burden to roll out
changes. I would argue that an in-tree change should be all that is
necessary to change the behavior of official automation infrastructure.</p>
<p>How this is accomplished, I'm not entirely certain. In my ideal world,
I think <em>mozharness</em> would live in tree. Although, I understand that may
not be practical because much of what <em>mozharness</em> does involves
downloading just-built packages, uploading results to a server, etc. I
think a middle ground that accomplishes most of what we seek is for the
Release Engineering configs (<em>mozharness</em>) to contain as little logic as
possible for actual job invocation and let something in-tree do the
rest. For example, the <em>mozharness</em> job for the xpcshell test harness
would simply be <em>execute the run-xpcshell-tests script from the tests
archive.</em> <em>mozilla-central</em> could then have full domain over what
exactly is done. If <em>mozilla-central</em> changes, everyone picks up those
changes immediately.</p>
<h3>Local run-time environments different from official ones</h3>
<p>Similar in vein to the previous section is that there are discrepancies
between local run-time environments and official ones. By run-time
environment, I mean the state of the operating system (installed
packages, configuration settings, etc). This plays an important role in
determining how an automation job executes. An obvious example is the
compiler toolchain. GCC 4.5 is obviously going to have different
behavior from GCC 4.7.</p>
<p>While Release Engineering has taken steps to ensure consistency in the
configuration of the machines powering the official automation
infrastructure, local machine configurations are effectively living in
the wild west. Developers are effectively unable to recreate the
official automation environment. This lowers the liklihood that a local
build will have the same outcome when performed on official automation
infrastructure.</p>
<p>While supporting diverse run-time environments will result in greater
compatibility and is thus a good thing, I think it is important that
local developers have the ability to recreate the official run-time
environment as closely as possible. This will raise confidence that
local results can be trusted and should cut down on development
cost by reducing the number of Try pushes and reducing development
cycles.</p>
<p>Recreating the official run-time environment varies in difficulty
depending on the operating system. For Linux, it should actually be
pretty easy! For the build environment, Mozilla simply needs to package
the <em>mock</em> environment used to build or at least could publish a script
used to create said environment. In
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=886226">bug 886226</a>, I
made an initial stab at this by creating a Vagrantfile that will
kinda/sorta recreate the official 64-bit Linux build environment. I even
published an archive of the <em>mock</em> environment (which can be imported
into <em>Docker</em>). As pointed out on the bug, my work isn't perfect. But
it's a start. And it's better than what developers have today to
reproduce the official environments.</p>
<p>If we decide publishing archives of chroot environments is the way to
go, I believe we could extend the Linux solution to OS X as well. OS X
has chroot. It also has a sandboxing facility (<em>man sandbox</em>). There are
also tools like <a href="http://freecode.com/projects/jailkit">jailkit</a>. Also,
using chroot environments will also likely make our automation faster
since using archives will almost surely be faster than recreating the
environment on every job run.
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=851294">Bug 851294</a> has
been filed to track this.</p>
<p>What about Windows? Well, I don't know. We sort of have an environment
with <a href="https://ftp.mozilla.org/pub/mozilla.org/mozilla/libraries/win32/MozillaBuildSetup-Latest.exe">MozillaBuild</a>.
But, it's not isolated from the rest of the operating system like chroot
environments are. Modulo Windows, two out of three tier one platforms
isn't too bad!</p>
<p>Now, even if the software environment is similar, hardware differences
can also affect results. Unfortunately, there's little that can be done
on this front aside from having everybody use the same hardware models.
That's not going to happen. So let's pretend we don't have that problem.</p>
<h3>Configurations change over time</h3>
<p>I recently wrote a
<a href="/blog/2013/06/24/the-importance-of-time-on-automated-machine-configuration/">post on the importance of time on machine configurations</a>.
The gist is that configurations always pulling from version control tip
or relying on external resource often vary with time and aren't truly
idempotent. This makes it difficult to reproduce specific configurations
at future points in time.</p>
<p>Unfortunately, Mozilla's build automation is highly susceptible to
configuration variance over time. There are many examples.</p>
<p>The buildbot configuration is periodically pushed to the
infrastructure. A job will inherit the config that is currently
deployed. If you make a backwards incompatible change to the buildbot
configs and push an old revision of mozilla-central, things will blow
up.</p>
<p>There are two time-dependent aspects of Puppet bootstrapping. First, the
Puppet configs (like buildbot configs) are periodically pushed to a
central master server. Whichever version is deployed at a given time is
the version picked up by the automation job. Second, we don't do a good
job of pinning versions inside the Puppet config. Here are the
<a href="https://hg.mozilla.org/build/puppet/file/6f7b4a33af2c/modules/packages/manifests/mercurial.pp">Mercurial</a>,
<a href="https://hg.mozilla.org/build/puppet/file/6f7b4a33af2c/modules/packages/manifests/mock.pp">mock</a>,
and <a href="https://hg.mozilla.org/build/puppet/file/6f7b4a33af2c/modules/packages/manifests/mozilla/py27_mercurial.pp">Python</a>
manifests using the <em>latest</em> package version. This means if a new
version of a package is added to
<a href="http://puppetagain.pub.build.mozilla.org/data/repos/yum/">Mozilla's Yum repositories</a>
that new package version will be deployed on the next Puppet sync.
This is definitely not time independent. Fortunately, the base operating
system configuration for Linux isn't terribly important because of the
<em>mock</em> environment. But, it still varies.</p>
<p>Like the base operating system, the mock environment is full of
dependence on time. First, the config file itself is managed by Puppet
and thus susceptible to its time-dependent behavior. Second, the
packages installed in the mock environment aren't version pinned.
This means that whatever packages deployed in
<a href="http://puppetagain.pub.build.mozilla.org/data/repos/yum/">Mozilla's Yum repositories</a>
will be used. So, every time the Yum package repository is updated, we
potentially switch the configuration of our build environment. On the
surface, this terrifies me. Maybe we have a strict update policy in
place to prevent excessive package updates. The
<a href="http://puppetagain.pub.build.mozilla.org/data/repos/yum/mirrors/centos/6/latest/os/x86_64/">modified times</a>
of packages on the server seems to indicate that. Even if we didn't
update the package repository, it still seems a bit fragile: I'd much
prefer to pin package versions everywhere than rely on the content of
a Yum server.</p>
<p>The default branch of the <a href="https://hg.mozilla.org/build/tools">tools repository</a>
is always checked out at build time. As new revisions are added to this
repository, builds will pick them up immediately. If you make a
backwards incompatible change to the tools repository, old revisions may
no longer build.</p>
<p>The production branch of the
<a href="https://hg.mozilla.org/build/mozharness/">mozharness repository</a> is
always used during jobs. Again, if <em>mozharness</em> changes, every future
job sees these changes.</p>
<p>The takeaway here is that many of the tightly-related
systems/repositories aren't linked in any way. The automation
configuration simply pulls the tip of each. We run into problems when we
wish to make backwards incompatible changes. If you make one, you first
have to update all repositories to be compatible. This is a huge pain
(see my experience above). Furthermore, it makes it impossible to have
successful automation runs from old revisions of those repositories!</p>
<p>The solution to this mess is to pin versions and configs everywhere.
The repositories being put through automation (namely <em>mozilla-central</em>)
should contain revisions of the configs to use. It should say <em>I want to
use revision X of mozharness, revision Y of the build machine
configuration, etc.</em> This will enable much more consistent automation
output over time. It cuts down on surprises (<em>did behavior change on July
14 because of a change to mozilla-central or to a new automation config
being rolled out to the server?</em>). It allows people to build very old
packages. This means Mozilla wouldn't need to store terabytes of old
builds around (we could just trigger the build again and get the same
output).</p>
<p>I recognize that deterministic automation configuration is likely not
completely achievable. But, that doesn't mean we shouldn't work towards
it. Having something better than today enables so many more useful
scenarios and flexibility in our automation. Let me explain.</p>
<p>Say you want to add or remove a test harness. Or, maybe you want to add
a required argument or remove an obsolute argument from a test harness.
The procedure from doing this today is far from trivial. It's not enough
to simply land your change in mozilla-central and be done with it. Instead,
you need to land support in <em>buildbotcustom</em> or <em>mozharness</em>, prepare to
land in mozilla-central, then coordinate with Release Engineering to have your
changes landed around the time of a server deployment. And since changes
likely affect multiple trees, you're likely also landing things in
inbound, fx-team, services-central, possibly aurora, beta, and release,
etc. If you aren't landing in aurora, beta, release, esr, b2g, etc, you
need to remember to have your change merged into these server configurations
when those trees inherit your code (although Release Engineering is
typically pretty good about tracking this and doing it for you).</p>
<p>Contrast this with simply making a backwards incompatible change by
checking in support in <em>mozharness</em> then making the change in
<em>mozilla-central</em> along with a revision bump of the <em>mozharness</em>
revision to use. When that changeset is pushed to the infrastructure, a
compatible version of <em>mozharness</em> is used. When that change gets merged
into other trees, the appropriate <em>mozharness</em> revision is used. No
extra work needed. Utopia. You just made A*Team and Release Engineering
much more productive by eliminating a lot of overhead.</p>
<h2>Conclusion</h2>
<p>The Mozilla automation infrastructure is a complex beast. There are many
moving parts and separate systems. Any newcomer to Mozilla should simply
stand in awe that so many systems seemlessly work so well together.</p>
<p>There are improvements that can be made, sure (especially in the area of
deterministic behavior over time). But, I think with the <em>mozharness</em>
work and the <em>Puppetization</em> of the server infrastructure that Mozilla
is on the right course. I look forward to a future where the source code
in <em>mozilla-central</em> and the automation infrastructure are more tightly
integrated. We're trending there. Give it time.</p>]]></content:encoded>
    </item>
    <item>
      <title>Quantifying Mozilla's Automation Efficiency</title>
      <link>http://gregoryszorc.com/blog/2013/07/14/quantifying-mozilla's-automation-efficiency</link>
      <pubDate>Sun, 14 Jul 2013 23:15:00 PDT</pubDate>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2013/07/14/quantifying-mozilla's-automation-efficiency</guid>
      <description>Quantifying Mozilla's Automation Efficiency</description>
      <content:encoded><![CDATA[<p>Mozilla's build and test automation
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=859573">now records</a>
system resource usage (CPU, memory, and I/O) during mozharness jobs.
It does this by adding a generic resource collection feature to
mozharness. If a mozharness script inherits from a specific class, it
magically performs system resource collection and reporting!</p>
<p>I want to emphasize that the current state of the feature is far from
complete. There are numerous shortcomings and areas for improvement:</p>
<ul>
<li>At the time I'm writing this, the mozharness patch is only
  deployed on the Cedar tree. Hopefully it will be deployed to the
  production infrastructure shortly.</li>
<li>This feature only works for mozharness jobs. Notably absent are
  desktop builds.</li>
<li>psutil - the underlying Python package used to collect data - isn't
  yet installable everywhere. As Release Engineering rolls it out to
  other machine classes in <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=893254">bug 893254</a>,
  those jobs will magically start collecting resource usage.</li>
<li>While detailed resource usage is captured during job execution, we
  currently only report a very high-level summary at job completion
  time. This will be addressed with
  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=893388">bug 893388</a>.</li>
<li>Jobs running on virtual machines appear to misreport CPU usage
  (presumably due to CPU steal being counted as utilized CPU).
  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=893391">Bug 893391</a>
  tracks.</li>
<li>You need to manually open logs to view resource usage. (e.g. open
  <a href="https://ftp.mozilla.org/pub/mozilla.org/firefox/tinderbox-builds/cedar-macosx64/1373828505/cedar_mountainlion_test-xpcshell-bm77-tests1-macosx-build30.txt.gz">this log</a>
  and search for <em>Total resource usage</em>.) I hope to one day have key
  metrics reported in TBPL output and/or easily graphable.</li>
<li>Resource collection operates at the system level. Because there is
  only 1 job running on a machine and slaves typically do little else,
  we assume system resource usage is a sufficient proxy for automation
  job usage. This obviously isn't always correct. But, it was the
  easiest to initially implement.</li>
</ul>
<p>Those are a lot of shortcomings! And, it essentially means only OS X
test jobs are providing meaningful data now. But, you have to start
somewhere. And, we have more data now than we did before. That's
progress.</p>
<h2>Purpose and Analysis</h2>
<p>Collecting resource usage of automation jobs (something I'm quite frankly
surprised we weren't doing before) should help raise awareness of
inefficient machine utilization and other hardware problems. It will
allow us to answer questions such as <em>are the machines working as hard
as they can</em> or <em>is a particular hardware component contributing to
slower automation execution.</em></p>
<p>Indeed a casual look at the first days of the data has shown some
alarming readings, notably the abysmal CPU efficiency of our test jobs.
For an OS X 10.8 opt build, the
<a href="https://ftp.mozilla.org/pub/mozilla.org/firefox/tinderbox-builds/cedar-macosx64/1373828505/cedar_mountainlion_test-xpcshell-bm77-tests1-macosx-build30.txt.gz">xpcshell</a>
job only utilized an average of 10% CPU during execution. A
<a href="https://ftp.mozilla.org/pub/mozilla.org/firefox/tinderbox-builds/cedar-macosx64/1373828505/cedar_mountainlion_test-mochitest-browser-chrome-bm77-tests1-macosx-build26.txt.gz">browser chrome</a>
job only utilized 12% CPU on average. Finally, a
<a href="https://ftp.mozilla.org/pub/mozilla.org/firefox/tinderbox-builds/cedar-macosx64/1373828505/cedar_mountainlion_test-reftest-bm77-tests1-macosx-build21.txt.gz">reftest</a>
job only utilized 13%.</p>
<p>Any CPU cycle not utilized by our automation infrastructure is forever
lost and cannot be put to work again. So, to only utilize 10-13% of
available CPU cycles during test jobs is wasting a lot of machine
potential. This is the equivalent of buying 7.7 to 10 machines and only
turning 1 of them on! Or, in terms of time, it would reduce the wall
time execution of a 1 hour job to 6:00 to 7:48. Or in terms of
overall automation load, it would significantly decrease the backlog and
turnaround time. You get my drift. This is why parallelizing test
execution within test suites - a means to increase CPU utilization - is
such an exciting project to me. This work is all tracked in
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=845748">bug 845748</a> and in
my opinion it cannot complete soon enough. (I'd also like to see more
investigation into bottlenecks in test execution. Even small
improvements of 1 or 2% can have a measurable impact when multiplied by
thousands of tests per suite and hundreds of test job runs per day.)</p>
<p>Another interesting observation is that there is over 1 GB of write I/O
during some test jobs. Browser chrome tests write close to 2GB! That is
surprisingly high to me. Are the tests really incurring that much I/O?
If so, which ones? Do they need to? If not tests, what background
service is performing that much work? Could I/O wait be slowing tests
down? Should we invest in more SSDs? More science is definitely needed.</p>
<p>I hope people find this data useful and that we put it to use to
make more data-driven decisions around Mozilla's automation
infrastructure.</p>]]></content:encoded>
    </item>
    <item>
      <title>The Importance of Time on Automated Machine Configuration</title>
      <link>http://gregoryszorc.com/blog/2013/06/24/the-importance-of-time-on-automated-machine-configuration</link>
      <pubDate>Mon, 24 Jun 2013 21:00:00 PDT</pubDate>
      <category><![CDATA[sysadmin]]></category>
      <category><![CDATA[Mozilla]]></category>
      <category><![CDATA[Puppet]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2013/06/24/the-importance-of-time-on-automated-machine-configuration</guid>
      <description>The Importance of Time on Automated Machine Configuration</description>
      <content:encoded><![CDATA[<p>Usage of machine configuration management software like Puppet
and Chef has taken off in recent years. And rightly so - these
pieces of software make the lives of countless system
administrators much better (in theory).</p>
<p>In their default (and common) configuration, these pieces of
software do a terrific job of ensuring a machine is provisioned with
<em>today's</em> configuration. However, for many server provisioning
scenarios, we actually care about <em>yesterday's</em> configuration.</p>
<p>In this post, I will talk about the importance of time when configuring
machines.</p>
<h2>Describing the problem</h2>
<p>If you've worked on any kind of server application, chances are
you've had to deal with a rollback. Some new version of a package
or web application is rolled out to production. However, due to
unforeseen problems, it needed to be rolled back.</p>
<p>Or, perhaps you operate a farm of machines that continuously build
or compile software from version control. It's desirable to be able
to reproduce the output from a previous build (ideally bit
identical).</p>
<p>In these scenarios, the wall time plays a crucial rule when dealing
with a central, master configuration server (such as a Puppet
master).</p>
<p>Since a client will always pull the latest revision of its
configuration from the server, it's very easy to define your
configurations such that the result of machine provisioning
today is different from yesterday (or last week or last month).</p>
<p>For example, let's say you are running Puppet to manage a machine
that sits in a continuous integration farm and recompiles a source
tree over and over. In your Puppet manifest you have:</p>
<pre><code>package {
    "gcc":
        ensure =&gt; latest
}
</code></pre>
<p>If you run Puppet today, you may pull down GCC 4.7 from the remote
package repository because 4.7 is the latest version available. But
if you run Puppet tomorrow, you may pull down GCC 4.8 because the
package repository has been updated! If for some reason you need
to rebuild one of today's builds tomorrow (perhaps you want to
rebuild that revision plus a minor patch), they'll use different
compiler versions (or any package for that matter) and the output
may not be consistent - it may not even work at all! So much for
repeatability.</p>
<p>File templates are another example. In Puppet, file templates are
evaluated on the server and the results are sent to the client. So,
the output of file template execution today might be different from
the output tomorrow. If you needed to roll back your server to an
old version, you may not be able to do that because the template
on the server isn't backwards compatible! This can be worked around,
sure (commonly by copying the template and branching differences),
but over time these hacks accumulate in a giant pile of complexity.</p>
<p>The common issue here is that time has an impact on the outcome of
machine configuration. I refer to this issue as <strong>time-dependent
idempotency</strong>. In other words, does time play a role in the
supposedly idempotent configuration process? If the output is
consistent no matter <em>when</em> you run the configuration, it is
time-independent and truly idempotent. If it varies depending on
when configuration is performed, it is time-dependent and thus
not truly idempotent.</p>
<h2>Solving the problem</h2>
<p>My attitude towards machine configuration and automation is that
it should be as time independent as possible. If I need to revert
to yesterday's state or want to reproduce something that happened
months ago, I want strong guarantees that it will be similar, if not
identical. Now, this is just my opinion. I've worked in environments
where we had these strong guarantees. And having had this luxury,
I abhore the alternative where so many pieces of configuration vary
over time as the central configuration moves forward without the
ability to turn back the clock. As always, your needs may be
different and this post may not apply to you!</p>
<p>I said <em>as possible</em> a few times in the previous paragraph.
While you could likely make all parts of your configuration time
independent, it's not a good idea. In the real world, things
change over time and making all configuration data static regardless
of time will produce a broken or bad configuration.</p>
<p>User access is one such piece of configuration. Employees come and
go. Passwords and SSH keys change. You don't want to revert user
access to the way it was two months ago, restoring access to a
disgruntled former employee or allowing access via a compromised
password. Network configuration is another. Say the network topology
changed and the firewall rules need updating. If you reverted the
networking configuration, the machine likely wouldn't work on the
network!</p>
<p>This highlights an important fact: <strong>if making your machine
configuration time independent is a goal, you will need to
bifurcate configuration by time dependency and solve for both.</strong>
You'll need to identify every piece of configuration and
ask <em>do I put this in the bucket that is constant over time or
the bucket that changes over time?</em></p>
<p>Machine configuration software can do a terrific job of ensuring
an applied configuration is idempotent. The problem is it typically
can't manage both time-dependent and time-independent attributes
at the same time. Solving this requires a little brain power, but
is achievable if there is will. In the next section, I'll describe
how.</p>
<h3>Technical implementation</h3>
<p>Time-dependent machine configuration is a solved problem. Deploy
Puppet master (or similar) and you are good to go.</p>
<p>Time-independent configuration is a bit more complicated.</p>
<p>As I mentioned above, the first step is to isolate all of the
configuration you want to be time independent. Next, you need to
ensure time dependency doesn't creep into that configuration. You
need to identify things that can change over time and take
measures to ensure those changes won't affect the configuration.
I encourage you to employ the <em>external system
test</em>: <em>does this aspect of configuration depend on an external
system or entity? If so how will I prevent changes in it over
time from affecting us?</em></p>
<p>Package repositories are one such external system. New package
versions are released all the time. Old packages are deleted.
If your configuration says to install the <em>latest</em> package, there's
no guarantee the package version won't change unless the package
repository doesn't change. If you simply pin a package to a specific
version, that version may disappear from the server. The solution:
pin packages to specific versions <strong>and</strong> run your own package
mirror that doesn't delete or modify existing packages.</p>
<p>Does your configuration fetch a file from a remote server or use
a file as a template? Cache that file locally (in case it
disappears) and put it under version control. Have the configuration
reference the version control revision of that file. As long as the
repository is accessible, the exact version of the file can be
retrieved at any time without variation.</p>
<p>In my professional career, I've used two separate systems for
managing time-independent configuration data. Both relied heavily
on version control. Essentially, all the time-independent
configuration data is collected into a single repository - an
independent repository from all the time-dependent data
(although that's technically an implementation detail). For Puppet,
this would include all the manifests, modules, and files used
directly by Puppet. When you want to <em>activate</em> a machine with
a configuration, you simply say <em>check out revision X of this
repository and apply its configuration.</em> Since <em>revision X</em> of
the repository is constant over time, the set of configuration
data being used to configure the machine is constant. And, if
you've done things correctly, the output is idempotent over time.</p>
<p>In one of these systems, we actually had two versions of Puppet
running on a machine. First, we had the daemon communicating with a
central Puppet master. It was continually applying time-dependent
configuration (user accounts, passwords, networking, etc). We
supplemented this was a manually executed standalone Puppet
instance. When you ran a script, it asked the Puppet master for its
configuration. Part of that configuration was the revision of the
time-independent Git repository containing the Puppet configuration
files the client should use. It then pulled the Git repo, checked
out the specified revision, merged Puppet master's settings for the
node with that config (not the manifests, just some variables),
then ran Puppet locally to apply the configuration. While a
machine's configuration typically referenced a SHA-1 of a specific
Git commit to use, we could use anything <em>git checkout</em> understood.
We had some machines running <em>master</em> or other branches if we didn't
care about time-independent idempotency for that machine at that
time. What this all meant was that if you wanted to roll back
a machine's configuration, you simply specified an earlier Git
commit SHA-1 and then re-ran local Puppet.</p>
<p>We were largely satisfied with this model. We felt like we got
the best of both worlds. And, since we were using the same
technology (Puppet) for time-dependent and time-independent
configuration, it was a pretty simple-to-understand system.
A downside was there were two Puppet instances instead of one.
With a little effort, someone could probably devise a way for
the Puppet master to <em>merge</em> the two configuration trees. I'll
leave that as an exercise for the reader. Perhaps someone has
done this already! If you know of someone, please leave a comment!</p>
<h3>Challenges</h3>
<p>The solution I describe does not come without its challenges.</p>
<p>First, deciding whether a piece of configuration is time dependent
or time independent can be quiet complicated. For example,
should a package update for a critical security fix be time
dependent or time independent? It depends! What's the risk of
the machine not receiving that update? How often is that machine
rolled back? Is that package important to the operation/role
of that machine (if so, I'd lean more towards time independent).</p>
<p>Second, minimizing exposure to external entities is hard. While
I recommend putting as much as possible under version control in a
single repository and pinning versions everywhere when you interface
with an external system, this isn't always feasible. It's probably
a silly idea to have your 200 GB Apt repository under version
control and distributed locally to every machine in your network.
So, you end up introducing specialized one-off systems as necessary.
For our package repository, we just ran an internal HTTP server that
only allowed inserts (no deletes or mutates). If we were creative, we
could have likely devised a way for the client to pass a <em>revision</em> with
the request and have the server dynamically serve from that revision
of an underlying repository. Although, that may not work for every
server type due to limited control over client behavior.</p>
<p>Third, ensuring compatibility between the time-dependent configuration
and time-independent configuration is hard. This is a consequence of
separating those configurations. Will a time-independent configuration
from a revision two years ago work with the time-dependent
configuration of today? This issue can be mitigated by first
having as much configuration as possible be time independent and
second not relying on wide support windows. If it's good enough
to only support compatibility for time-independent configurations
less than a month old, then it's good enough! With this issue, I feel
you are trading long-term future incompatibility for well-defined
and understood behavior in the short to medium term. That's
a trade-off I'm willing to make.</p>
<h2>Conclusion</h2>
<p>Many machine configuration management systems only care about
idempotency <em>today</em>. However, with a little effort, it's possible
to achieve consistent state over time. This requires a little extra
effort and brain power, but it's certainly doable.</p>
<p>The next time you are programming your system configuration tool, I
hope you take the time to consider the effects time will have and that
you will take the necessary steps to ensure consistency over time
(assuming you want that, of course).</p>]]></content:encoded>
    </item>
    <item>
      <title>Using Docker to Build Firefox</title>
      <link>http://gregoryszorc.com/blog/2013/05/19/using-docker-to-build-firefox</link>
      <pubDate>Sun, 19 May 2013 13:45:00 PDT</pubDate>
      <category><![CDATA[Mozilla]]></category>
      <category><![CDATA[Firefox]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2013/05/19/using-docker-to-build-firefox</guid>
      <description>Using Docker to Build Firefox</description>
      <content:encoded><![CDATA[<p>I have the privilege of having my desk located around a bunch of
really intelligent people from the Mozilla Services team. They've been
talking a lot about all the new technologies around server provisioning.
One that interested me is <a href="http://www.docker.io/">Docker</a>.</p>
<p>Docker is a pretty nifty piece of software. It's essentially a glorified
wrapper around <a href="http://lxc.sourceforge.net/">Linux Containers</a>. But,
calling it that is doing it an injustice.</p>
<p>Docker interests me because it allows simple environment isolation and
repeatability. I can create a run-time environment
once, package it up, then run it again on any other machine.
Furthermore, everything that runs in that environment is isolated from
the underlying host (much like a virtual machine). And best of all,
everything is fast and simple.</p>
<p>For my initial experimentation with Docker, I decided to create an
environment for building Firefox.</p>
<h2>Building Firefox with Docker</h2>
<p>To build Firefox with Docker, you'll first need to
<a href="http://www.docker.io/gettingstarted/">install</a> Docker. That's pretty
simple.</p>
<p>Then, it's just a matter of creating a new container with our build
environment:</p>
<div class="pygments_murphy"><pre>curl https://gist.github.com/indygreg/5608534/raw/30704c59364ce7a8c69a02ee7f1cfb23d1ffcb2c/Dockerfile | docker build
</pre></div>

<p>The output will look something like:</p>
<div class="pygments_murphy"><pre>FROM ubuntu:12.10
MAINTAINER Gregory Szorc &quot;gps@mozilla.com&quot;
RUN apt-get update
===&gt; d2f4faba3834
RUN dpkg-divert --local --rename --add /sbin/initctl &amp;&amp; ln -s /bin/true /sbin/initctl
===&gt; aff37cc837d8
RUN apt-get install -y autoconf2.13 build-essential unzip yasm zip
===&gt; d0fc534feeee
RUN apt-get install -y libasound2-dev libcurl4-openssl-dev libdbus-1-dev libdbus-glib-1-dev libgtk2.0-dev libiw-dev libnotify-dev libxt-dev mesa-common-dev uuid-dev
===&gt; 7c14cf7af304
RUN apt-get install -y binutils-gold
===&gt; 772002841449
RUN apt-get install -y bash-completion curl emacs git man-db python-dev python-pip vim
===&gt; 213b117b0ff2
RUN pip install mercurial
===&gt; d3987051be44
RUN useradd -m firefox
===&gt; ce05a44dc17e
Build finished. image id: ce05a44dc17e
ce05a44dc17e
</pre></div>

<p>As you can see, it is essentially <em>bootstrapping</em> an environment to
build Firefox.</p>
<p>When this has completed, you can activate a shell in the container by
taking the image id printed at the end and running it:</p>
<div class="pygments_murphy"><pre>docker run -i -t ce05a44dc17e /bin/bash
<span class="c"># You should now be inside the container as root.</span>
su - firefox
hg clone https://hg.mozilla.org/mozilla-central
<span class="nb">cd </span>mozilla-central
./mach build
</pre></div>

<p>If you want to package up this container for distribution, you just find
its ID then export it to a tar archive:</p>
<div class="pygments_murphy"><pre>docker ps -a
<span class="c"># Find ID of container you wish to export.</span>
docker <span class="nb">export </span>2f6e0edf64e8 &gt; image.tar
<span class="c"># Distribute that file somewhere.</span>
docker import - &lt; image.tar
</pre></div>

<p>Simple, isn't it?</p>
<h2>Future use at Mozilla</h2>
<p>I think it would be rad if Release Engineering used Docker for managing
their Linux builder configurations. Want to develop against the exact
system configuration that Mozilla uses in its automation - you could do
that. No need to worry about custom apt repositories, downloading
custom toolchains, keeping everything isolated from the rest of your
system, etc: Docker does that all automatically. Mozilla simply needs to
publish Docker images on the Internet and anybody can come along and
reproduce the official environment with minimal effort. Once we do that,
there are few excuses for someone breaking Linux builds because of
an environment discrepancy.</p>
<p>Release Engineering could also use Docker to manage isolation of
environments between builds. For example, it could spin up a new
container for each build or test job. It could even save images from the
results of these jobs. Have a weird build failure like a segmentation
fault in the compiler? Publish the Docker image and have someone take a
look! No need to take the builder offline while someone SSH's into it.
No need to worry about the probing changing state because you can always
revert to the state at the time of the failure! And, builds would likely
start faster. As it stands, our automation <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=851294">spends minutes managing
packages</a> before
builds begin. This lag would largely be eliminated with Docker. If
nothing else, executing automation jobs inside a container would allow
us to extract accurate resource usage info (CPU, memory, I/O) since
the Linux kernel effectively gives containers their own namespace
independent of the global system's.</p>
<p>I might also explore publishing Docker images that construct an ideal
development environment (since getting recommended tools in the hands of
everybody is a hard problem).</p>
<p>Maybe I'll even consider hooking up build system glue to automatically
run builds inside containers.</p>
<p>Lots of potential here.</p>
<h2>Conclusion</h2>
<p>I encourage Linux users to play around with Docker. It enables some
new and exciting workflows and is a really powerful tool despite its
simplicity. So far, the only major faults I have with it are that the
docs say it should not be used in production (yet) and it only works on
Linux.</p>]]></content:encoded>
    </item>
    <item>
      <title>Build System Status Update 2013-05-14</title>
      <link>http://gregoryszorc.com/blog/2013/05/13/build-system-status-update-2013-05-14</link>
      <pubDate>Mon, 13 May 2013 19:35:00 PDT</pubDate>
      <category><![CDATA[Mozilla]]></category>
      <category><![CDATA[build system]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2013/05/13/build-system-status-update-2013-05-14</guid>
      <description>Build System Status Update 2013-05-14</description>
      <content:encoded><![CDATA[<p>I'd like to make an attempt at delivering regular status updates on the
Gecko/Firefox build system and related topics. Here we go with the
first instance. I'm sure I missed awesomeness. Ping me and I'll add it
to the next update.</p>
<h2>MozillaBuild Windows build environment updated</h2>
<p>Kyle Huey
<a href="https://groups.google.com/d/msg/mozilla.dev.platform/XRecAHF-H28/aSbrdKJLUNoJ">released version 1.7</a>
of our Windows build environment. It contains a newer version of Python
and a modern version of Mercurial among other features.</p>
<p><strong>I highly recommend every Windows developer update ASAP.</strong> Please note
that you will likely encounter Python errors unless you clobber your
build.</p>
<h2>New submodule and peers</h2>
<p>I used my power as module owner to create a submodule of the build
config module whose scope is the (largely mechanical) transition of
content from Makefile.in to moz.build files. I granted Joey Armstrong
and Mike Shal peer status for this module. I would like to eventually
see both elevated to build peers of the main build module.</p>
<h2>moz.build transition</h2>
<p>The following progress has been made:</p>
<ul>
<li>Mike Shal has converted variables related to defining XPIDL files in
  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=818246">bug 818246</a>.</li>
<li>Mike Shal converted MODULE in
  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=844654">bug 844654</a>.</li>
<li>Mike Shal converted EXPORTS in
  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=846634">bug 846634</a>.</li>
<li>Joey Armstrong converted xpcshell test manifests in
  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=844655">bug 844655</a>.</li>
<li>Brian O'Keefe converted PROGRAM in
  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=862986">bug 862986</a>.</li>
<li>Mike Shal is about to land conversion of CPPSRCS in
  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=864774">bug 864774</a>.</li>
</ul>
<h2>Non-recursive XPIDL generation</h2>
<p>In <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=850380">bug 850380</a>
I'm trying to land non-recursive building of XPIDL files. As part of
this I'm trying to combine the generation of .xpt and .h for each input
.idl file into a single process call because profiling revealed that
parsing the IDL consumes most of the CPU time. This shaves a few dozen
seconds off of build times.</p>
<p>I have encounterd multiple pymake bugs when developing this patch, which
is the primary reason it hasn't landed yet.</p>
<h2>WebIDL refactoring</h2>
<p>I was looking at my build logs and noticed WebIDL generation was taking
longer than I thought it should. I filed
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=861587">bug 861587</a> to
investigate making it faster. While my initial profiling turned out to
be wrong, Boris Zbarsky looked into things and discovered that the
serialization and deserialization of the parser output was extremely
slow. He is currently trying to land a refactor of how WebIDL bindings
are handled. The early results look <strong>very</strong> promising.</p>
<p>I think the bug is a good example of the challenges we face improving
the build system, as Boris can surely attest.</p>
<h2>Test directory reorganization</h2>
<p>Joel Maher is injecting sanity into the naming scheme of test
directories in
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=852065">bug 852065</a>.</p>
<h2>Manifests for mochitests</h2>
<p>Jeff Hammel, Joel Maher, Ted Mielczarek, and I are working out using
manifests for mochitests (like xpcshell tests) in
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=852416">bug 852416</a>.</p>
<h2>Mach core is now a standalone package</h2>
<p>I extracted the mach core to a
<a href="https://github.com/indygreg/mach">standalone repository</a> and
<a href="https://pypi.python.org/pypi/mach/">added it to PyPI</a>.</p>
<p>Mach now <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=856392">categorizes</a>
commands in its help output.</p>
<h2>Requiring Python 2.7.3</h2>
<p>Now that the Windows build environment ships with Python 2.7.4, I've
filed <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=870420">bug 870420</a>
to require Python 2.7.3+ to build the tree. We already require
Python 2.7.0+. I want to bump the point release because there are
<a href="http://hg.python.org/cpython/file/d46c1973d3c4/Misc/NEWS">many</a> small
bug fixes in 2.7.3, especially around Python 3 compatibility.</p>
<p>This is currently blocked on RelEng rolling out 2.7.3 to all the
builders.</p>
<h2>Eliminating master xpcshell manifest</h2>
<p>Now that xpcshell test manifests are defined in moz.build files, we
theoretically don't need the master manifest. Joshua Cranmer is working
on removing them in
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=869635">bug 869635</a>.</p>
<h2>Enabling GTests and dual linking libxul</h2>
<p>Benoit Gerard and Mike Hommey are working in
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=844288">bug 844288</a> to
dual link libxul so GTests can eventually be enabled and executed as
part of our automation.</p>
<p>This will regress build times since we need to link libxul twice. But,
giving C++ developers the ability to write unit tests with a real
testing framework is worth it, in my opinion.</p>
<h2>ICU landing</h2>
<p>ICU was briefly enabled in
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=853301">bug 853301</a> but
then backed out because it broke cross-compiling. It should be on track
for enabling in Firefox 24.</p>
<h2>Resource monitoring in mozbase</h2>
<p>I <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=802420">gave mozbase</a>
a class to record system resource usage. I plan to eventually hook this
up to the build system so the build system records how long it took to
perform key events. This will give us better insight into slow and
inefficient parts of the build and will help us track build system speed
improvements over time.</p>
<h2>Sorted lists in moz.build files</h2>
<p>I'm working on requiring lists in moz.build be sorted. Work is happening
in <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=863069">bug 863069</a>.</p>
<p>This idea started as a suggestion on the dev-platform list. If anyone
has more great ideas, don't hold them back!</p>
<h2>Smartmake added to mach</h2>
<p>Nicholas Alexander
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=677452">taught mach</a> how
to build intelligently by importing some of Josh Matthews' smartmake
tool's functionality into the tree.</p>
<h2>Source server fixed</h2>
<p>Kyle Huey and Ted Mielczarek
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=846864">collaborated</a> to
fix the source server.</p>
<h2>Auto clobber functionality</h2>
<p>Auto clobber functionality was added to the tree. After flirting briefly
with on-by-default, we changed it to opt-in. When you encounter it, it
will tell you how to enable it.</p>
<h2>Faster clobbers on automation</h2>
<p>I was looking at build logs and identified we were inefficiently
performing clobber.</p>
<p>Massimo Gervasini and Chris AtLee
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=851270">deployed changes</a>
to automation to make it more efficient. My measurements showed a
Windows try build that took 15 fewer minutes to start - a <em>huge</em>
improvement.</p>
<h2>Upgrading to Mercurial 2.5.4</h2>
<p>RelEng is <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=741353">tracking</a>
the global deployment of Mercurial 2.5.4. hg.mozilla.org is
currently running 2.0.2 and automation is all over the map. The upgrade
should make Mercurial operations faster and more robust across the
board.</p>
<p>I'm considering adding code to mach or the build system that prompts the
user when her Mercurial is out of date (since an out of date Mercurial
can result in a sub-par user experience).</p>
<h2>Parallelize reftests</h2>
<p>Nathan Froyd is
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=813742">leading an effort</a>
to parallelize reftest execution. If he pulls this off, it could shave
hours off of the total automation load per checkin. Go Nathan!</p>
<h2>Overhaul of MozillaBuild in the works</h2>
<p>I am mentoring a pair of interns this summer. I'm still working out the
final set of goals, but I'm keen to have one of them overhaul the
MozillaBuild Windows development environment. Cross your fingers.</p>]]></content:encoded>
    </item>
    <item>
      <title>Mozilla Build System Brain Dump</title>
      <link>http://gregoryszorc.com/blog/2013/05/13/mozilla-build-system-brain-dump</link>
      <pubDate>Mon, 13 May 2013 17:25:00 PDT</pubDate>
      <category><![CDATA[build system]]></category>
      <category><![CDATA[Mozilla]]></category>
      <category><![CDATA[Firefox]]></category>
      <category><![CDATA[mach]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2013/05/13/mozilla-build-system-brain-dump</guid>
      <description>Mozilla Build System Brain Dump</description>
      <content:encoded><![CDATA[<p>I hold a lot of context in my head when it comes to the future of
Mozilla's build system and the interaction with it. I wanted to
perform a brain dump of sorts so people have an idea of where I'm
coming from when I inevitably propose radical changes.</p>
<h2>The sad state of build system interaction and the history of mach</h2>
<p>I believe that Mozilla's build system has had a poor developer
experience for as long as there has been a Mozilla build system.
Getting started with Firefox development was a rite of passage. It
required following (often out-of-date) directions on MDN. It
required finding pages through MDN search or asking other people
for info over IRC. It was the kind of process that turned away
potential contributors because it was just too damn hard.</p>
<p>mach - while born out of my initial efforts to radically change
the build system proper - morphed into a generic command
dispatching framework by the time it landed in mozilla-central.
It has one overarching purpose: provide a single gateway point for
performing common developer tasks (such as building the tree and
running tests). The concept was nothing new - individual developers
had long coded up scripts and tools to streamline workflows. Some
even published these for others to use. What set mach apart was a
unified interface for these <em>commands</em> (the mach script in the
top directory of a checkout) and that these productivity gains
were <strong>in the tree</strong> and thus easily discoverable and usable by
<em>everybody</em> without significant effort (just run <em>mach help</em>).</p>
<p>While mach doesn't yet satisfy everyone's needs, it's slowly
growing new features and making developers' lives easier with
every one. All of this is happening despite that there
is not a single person tasked with working on mach full time.
Until a few months ago, mach was largely my work. Recently, Matt
Brubeck has been contributing a flurry of enhancements - thanks
Matt! Ehsan Akhgari and Nicholas Alexander have contributed a
few commands as well! There are also a few people with a single
command to their name. This is fulfilling my original vision of
facilitating developers to scratch their own itches by
contributing mach commands.</p>
<p>I've noticed more people referencing mach in IRC channels. And,
more people get angry when a mach command breaks or changes
behavior. So, I consider the mach experiment a success. Is it
perfect, no. If it's not good enough for you, please file a bug
and/or code up a patch. If nothing else, please tell me: I love to
know about everyone's subtle requirements so I can keep them in
mind when refactoring the build system and hacking on mach.</p>
<h2>The object directory is a black box</h2>
<p>One of the ideas I'm trying to advance is that the object directory
should be considered a black box for the majority of developers. In
my ideal world, developers don't need to look inside the object
directory. Instead, they interact with it through condoned and
supported tools (like mach).</p>
<p>I say this for a few reasons. First, as the build config module owner
I would like the ability to massively refactor the <em>internals</em> of
the object directory without disrupting workflows. If people are
interacting directly with the object directory, I get significant
push back if things change. This inevitably holds back much-needed
improvements and triggers resentment towards me, build peers, and
the build system. Not a good situation. Whereas if people are
indirectly interacting with the object directory, we simply need to
maintain a consistent interface (like mach) and nobody should care
if things change.</p>
<p>Second, I believe that the methods used when directly interacting
with the object directory are often sub-par compared with going
through a more intelligent tool and that productivity suffers as a
result. For example, when you type <em>make</em> in inside the object
directory you need to know to pass <em>-j8</em>, use make vs pymake,
and that you also need to build <em>toolkit/library</em>, etc.
Also, by invoking make directly, you bypass other handy features,
such as automatic compiler warning aggregation (which only happens
if you invoke the build system through mach). If you go through a
tool like <em>mach</em>, you <em>should</em> automatically get the most ideal
experience possible.</p>
<p>In order for this vision to be realized, we need massive
improvements to tools like mach to cover the missing workflows that
still require direct object directory interaction. We also need people
to start using mach. I think increased mach usage comes after mach
has established itself as obviously superior to the alternatives
(I already believe it offers this for tasks like running tests).</p>
<h2>I don't want to force mach upon people but...</h2>
<p>Nobody likes when they are forced to change a process that has been
familiar for years. Developers especially. I get it. That's why
I've always attempted to position mach as an alternative to
existing workflows. If you don't like mach, you can always fall
back to the previous workflow. Or, you can improve mach (patches
more than welcome!). Having gone down the
please-use-this-tool-it's-better road before at other
organizations, I strongly believe that the best method to incur
adoption of a new tool is to gradually sway people through
obvious superiority and praise (as opposed to a mandate to switch).
I've been trying this approach with mach.</p>
<p>Lately, more and more people have been saying things like
<em>we should have the build infrastructure build through mach
instead of client.mk</em> and <em>why do we need testsuite-targets.mk when
we have mach commands.</em> While I personally feel that client.mk
and testsuite-targets.mk are antiquated as a developer-facing
interface compared to mach, I'm reluctant to eliminate them because
I don't like forcing change on others. That being said, there are
compelling reasons to eliminate or at least refactor how they work.</p>
<p>Let's take <em>testsuite-targets.mk</em> as an example. This is the make
file that provides the targets to run tests (like <em>make xpcshell-test</em>
and <em>make mochitest-browser-chrome</em>). What's interesting about this
file is that it's only used in local builds: our automation
infrastructure does not use <em>testsuite-targets.mk</em>! Instead,
<em>mozharness</em> and the old buildbot configs manually build up the
command used to invoke the test harnesses. Initially, the mach
commands for running tests simply invoked make targets defined
in <em>testsuite-targets.mk</em>. Lately, we've been converting the mach
commands to invoke the Python test runners directly. I'd argue that
the logic for <em>invoke the test runner</em> only needs to live in one
place in the tree. Furthermore as a build module peer, I have little
desire to support multiple implementations. Especially considering
how fragile they can be.</p>
<p>I think we're trending towards an outcome where mach (or the code
behind mach commands) transitions into the authoratitive invocation
method and <em>legacy</em> interfaces like <em>client.mk</em> and
<em>testsuite-targets.mk</em> are reimplemented to either call mach
commands or the same routine that powers them. Hopefully this
will be completely transparent to developers.</p>
<h2>The future of mozconfigs and environment configuration</h2>
<p><em>mozconfig</em> files are shell scripts used to define variables consumed
by the build system. They are the only officially supported mechanism
for configuring how the build system works.</p>
<p>I'd argue mozconfig files are a mediocre solution at best. First,
there's the issue of mozconfig statements that don't actually do
anything. I've seen no-op mozconfig content cargo culted into the
in-tree mozconfigs (used for the builder configurations)! Oops.
Second, doing things in mozconfig files is just awkward. Defining
the object directory requires <em>mk_add_options MOZ_OBJDIR=some-path</em>.
What's <em>mk_add_options</em>? If <em>some-path</em> is relative, what is it
relative <em>to</em>? While certainly addressable, the documentation on
how mozconfig files work is not terrific and fails to explain many
pitfalls. Even with proper documentation, there's still the issue
of the file format allowing no-op variable assignments to persist.</p>
<p>I'm very tempted to reinvent build configuration as something not
mozconfigs. What exactly, I don't know. mach has support for ini-like
configuration files. We could certainly have mach and the build
system pull configs from the same file.</p>
<p>I'm not sure what's going to happen here. But deprecating mozconfig
files as they are today is part of many of the options.</p>
<h2>Handling multiple mozconfig files</h2>
<p>A lot of developers only have a single mozconfig file (per source tree
at least). For these developers, life is easy. You simply install
your mozconfig in one of the default locations and it's automagically
used when you use mach or client.mk. Easy peasy.</p>
<p>I'm not sure what the relative numbers are, but many developers
maintain multiple mozconfig files per source tree. e.g. they'll
have one mozconfig to build desktop Firefox and another one for
Android. They may have debug variations of each.</p>
<p>Some developers even have a single mozconfig file but leverage the
fact that mozconfig files are shell scripts and have their
mozconfig dynamically do things depending on the current working
directory, value of an environment variable, etc.</p>
<p>I've also seen wrapper scripts that glorify setting environment
variables, changing directory, etc and invoke a command.</p>
<p>I've been thinking a lot about providing a common and well-supported
solution for switching between active build configurations.
<a href="https://developer.mozilla.org/en-US/docs/Developer_Guide/mach#Adding_mach_to_your_shell%27s_search_path">Installing mach on $PATH</a>
goes a long way to facilitate this. If you are in an object
directory, the mozconfig used when that object directory was
created is automatically applied. Simple enough. However, I want
people to start treating object directories as black boxes. So, I'd
rather not see people have their shell inside the object directory.</p>
<p>Whenever I think about solutions, I keep arriving at a
virtualenv-like solution. Developers would potentially need to
<em>activate</em> a Mozilla build environment (similar to how Windows
developers need to launch MozillaBuild). Inside this environment,
the shell prompt would contain the name of the current build
configuration. Users could switch between configurations using
<em>mach switch</em> or some other magic command on the $PATH.</p>
<p>Truth be told, I'm skeptical if people would find this useful. I'm
not sure it's that much better than exporting the MOZCONFIG
environment variable to define the active config. This one requires
more thought.</p>
<h2>The integration between the build environment and Python</h2>
<p>We use Python extensively in the build system and for common
developer tasks. mach is written in Python. moz.build processing
is implemented in Python. Most of the test harnesses are written in
Python.</p>
<p>Doing practically anything in the tree requires a Python
interpreter that knows about all the Python code in the tree and
how to load it.</p>
<p>Currently, we have two very similar Python environments. One is
a virtualenv created while running configure at the beginning of
a build. The other is essentially a cheap knock-off that mach
creates when it is launched.</p>
<p>At some point I'd like to consolidate these Python environments.
From any Python process we should have a way to automatically
bootstrap/activate into a well-defined Python environment. This
certainly sounds like establishing a unified Python virtualenv
used by both the build system and mach.</p>
<p>Unfortunately, things aren't straightforward. The virtualenv today
is constructed in the object directory. How do we determine the
current object directory? By loading the mozconfig file. How do we
do that? Well, if you are mach, we use Python. And, how does mach
know where to find the code to load the mozconfig file? You can
see the dilemma here.</p>
<p>A related issue is that of portable build environments. Currently, a
lot of our automation recreates the build system's virtualenv from
its own configuration (not that from the source tree). This has
and will continue to bite us. We'd <em>really</em> like to package up the
virtualenv (or at least its config) with tests so there is no
potential for discrepancy.</p>
<p>The inner workings of how we integrate with Python should be
invisible to most developers. But, I figured I'd capture it
here because it's an annoying problem. And, it's also related
to an <em>activated</em> build environment. What if we required all
developers to <em>activate</em> their shell with a Mozilla build
environment (like we do on Windows)? Not only would this solve
Python issues, but it would also facilitate simpler config
switching (outlined above). Hmmm...</p>
<h2>Direct interaction with the build system considered harmful</h2>
<p>Ever since there was a build system developers have been typing
<em>make</em> (or <em>make.py</em>) to build the tree. One of the goals of the
transition to <em>moz.build</em> files is to facilitate building the tree
with Tup. <em>make</em> will do nothing when you're not using Makefiles!
Another goal of the <em>moz.build</em> transition is to start
derecursifying the make build system such that we build things in
parallel. It's likely we'll produce monolithic make files and then
process <em>all</em> targets for a related class <em>IDLs</em>, <em>C++ compilation</em>,
etc in one invocation of <em>make</em>. So, uh, what happens during a partial
tree build? If a .cpp file from <em>/dom/src/storage</em> is being handled by
a monolithic make file invoked by the Makefile at the top of the
tree, how does a partial tree build pick that up? Does it build just
that target or every target in the monolithic/non-recursive make file?</p>
<p>Unless the build peers go out of our way to install redundant targets
in leaf Makefiles, directly invoking <em>make</em> from a subdirectory of
the tree won't do what it's done for years.</p>
<p>As I said above, I'm sympathetic to forced changes in procedure, so
it's likely we'll provide backwards-compatibile behavior. But, I'd
prefer to not do it. I'd first prefer partial-tree builds are not
necessary and a full tree build finishes quickly. But, we're not going
to get there for a bit. As an alternative, I'll take people building
through <em>mach build</em>. That way, we have an easily extensible interface
on which to build partial tree logic. We saw this recently when
dumbmake/smartmake landed. And, going through <em>mach</em> also reinforces my
ideal that the object directory is a black box.</p>
<h2>Semi-persistent state</h2>
<p>Currently, most state as it pertains to a checkout or build is in the
object directory. This is fine for artifacts from the build system.
However, there is a whole class of state that arguably shouldn't be in
the object directory. Specifically, it shouldn't be clobbered when you
rebuild. This includes logs from previous builds, the warnings database,
previously failing tests, etc. The list is only going to grow over time.</p>
<p>I'd like to establish a location for semi-persistant state related to
the tree and builds. Perhaps we change the clobber logic to ignore a
specific directory. Perhaps we start storing things in the user's home
directory. Perhaps we could establish a second <em>object directory</em> named
the <em>state directory</em>? How would this interact with <em>build environments</em>?</p>
<p>This will probably sit on the backburner until there is a compelling use
case for it.</p>
<h2>The battle against C++</h2>
<p>Compiling C++ consumes the bulk of our build time. Anything we can do to
speed up C++ compilation will work wonders for our build times.</p>
<p>I'm optimistic things like precompiled headers and compiling multiple
.cpp files with a single process invocation will drastically decrease
build times. However, no matter how much work we put in to make C++
compilation faster, we still have a giant issue: dependency hell.</p>
<p>As <a href="/presentations/2012-11-29-firefox-build-system/#34">shown</a> in my
build system presentation a few months back, we have dozens of header
files included by hundreds if not thousands of C++ files. If you change
one file: you invalidate build dependencies and trigger a rebuild. This
is why whenever files like mozilla-config.h change you are essentially
confronted with a full rebuild. ccache may help if you are lucky. But, I
fear that as long as headers proliferate the way they do, there is
little the build system by itself can do.</p>
<p>My attitude towards this is to wait and see what we can get out of
precompiled headers and the like. Maybe that makes it good enough. If
not, I'll likely be making a lot of noise at Platform meetings
requesting that C++ gurus brainstorm on a solution for reducing
header proliferation.</p>
<h2>Conclusion</h2>
<p>Belive it or not, these are only some of the topics floating around in
my head! But I've probably managed to bore everyone enough so I'll
call it a day.</p>
<p>I'm always interested in opinions and ideas, especially if they are
different from mine. I encourage you to leave a comment if you have
something to say.</p>]]></content:encoded>
    </item>
  </channel>
</rss>
