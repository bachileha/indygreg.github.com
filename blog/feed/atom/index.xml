<?xml version="1.0" encoding="UTF-8"?>
<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
   >
  <title type="text">Gregory Szorc's Digital Home</title>
  <subtitle type="text">Rambling on</subtitle>

  <updated>2013-10-15T20:00:50Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog" />
  <id>http://gregoryszorc.com/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://gregoryszorc.com/blog/feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[The State of the Firefox Build System (2013 Q3 Review)]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/10/15/the-state-of-the-firefox-build-system-(2013-q3-review)" />
    <id>http://gregoryszorc.com/blog/2013/10/15/the-state-of-the-firefox-build-system-(2013-q3-review)</id>
    <updated>2013-10-15T13:00:00Z</updated>
    <published>2013-10-15T13:00:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <category scheme="http://gregoryszorc.com/blog" term="build system" />
    <summary type="html"><![CDATA[The State of the Firefox Build System (2013 Q3 Review)]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/10/15/the-state-of-the-firefox-build-system-(2013-q3-review)"><![CDATA[<p>As we look ahead to Q4 planning for the Firefox build system, I wanted
to take the time to reflect on what was accomplished in Q3 and to
simultaneously look forward to Q4 and beyond.</p>
<h2>2013 Q3 Build System Improvements</h2>
<p>There were notable improvements in the build system during the last
quarter.</p>
<p>The issues our <em>customers</em> care most about is speed. Here is a list of
accomplishments in that area:</p>
<ul>
<li>
<p><em>MOZ_PSEUDO_DERECURSE</em> work to change how make directory traversal
  works. This enabled the <em>binaries</em> make target, which can do no-op
  libxul-only builds in just a few seconds. Of all the changes that
  landed this quarter, this is the most impactful to local build
  times. This change also enables C++ compilation to scale out to
  as many cores as you have. Previously, the build system was
  <em>starved</em> in many parts of the tree when compiling C++. Mike Hommey
  is responsible for this work. I reviewed most of it.</p>
</li>
<li>
<p>WebIDL and IPDL bindings are now compiled in <em>unified</em> mode,
  reducing compile times and linker memory usage. Nathan Froyd wrote the
  code. I reviewed the patches.</p>
</li>
<li>
<p>XPIDL files are generated much more efficiently. This removed a
  few minutes of CPU core time from builds. I wrote these patches and
  Mike Hommey reviewed.</p>
</li>
<li>
<p>Increased reliance on install manifests to process file installs.
  They have drastically reduced the number of processes required to
  build by performing all actions inside Python processes as system
  calls and removing the clownshoes of having to delete parts of the
  object directory at the beginning of builds. When many mochitests
  were converted to manifests, no-op build times dropped by ~15%
  on my machine. Many people are responsible for this work. Mike Hommey
  wrote the original install code for packaging a few months ago. I
  built in manifest file support, support for symlinks, and made the
  code a bit more robust and faster. Mike Hommey reviewed these
  patches.</p>
</li>
<li>
<p>Many bugs and issues around dependency files on Windows have been
  discovered and fixed. These were a common source of clobbers.
  Mike Hommey found most of these, many during his work to make
  MOZ_PSEUDO_DERECURSE work.</p>
</li>
<li>
<p>The effort to reduce C++ include hell is resulting in significantly
  shorter incremental builds. While this effort is largely outside the
  build config module, it is worth mentioning. Ehsan Akhgari is leading
  this effort. He's been assisted by too many people to mention.</p>
</li>
<li>
<p>The build system now has different build modes favoring faster
  building vs release build options depending on the environment. Mike
  Hommey wrote most (all?) of the patches.</p>
</li>
</ul>
<p>A number of other non-speed related improvements have been made:</p>
<ul>
<li>
<p>The build system now monitors resource usage during builds and can
  graph the results. I wrote the code. Ted Mielczarek, Mike Hommey,
  and Mike Shal had reviews.</p>
</li>
<li>
<p>Support for test manifests has been integrated with the build system.
  This enabled some build speed wins and is paving the road for better
  testing UX, such as the automagical <em>mach test</em> command, which will
  run the appropriate test suite automatically. Multiple people were
  involved in the work to integrate test manifests with the build
  system. I wrote the patches. But Ted Mielczarek got primary review.
  Joel Maher, Jeff Hammel, and Ms2ger provided excellent assistance
  during the design and implementation phase. The work around
  mochitest manifests likely wouldn't have happened this quarter if
  all of us weren't attending an A*Team work week in August.</p>
</li>
<li>
<p>There are now in-tree build system docs. They are
  <a href="https://ci.mozilla.org/job/mozilla-central-docs/Build_Documentation/index.html">published automatically</a>.
  Efforts have been made to purge MDN of cruft. I am responsible for
  writing the code and most of the docs. Benjamin Smedberg and Mike Shal
  performed code reviews.</p>
</li>
<li>
<p>Improvements have been made to object directory detection in mach.
  This was commonly a barrier to some users using mach. I am responsible
  for the code. Nearly every peer has reviewed patches.</p>
</li>
<li>
<p>We now require Python 2.7.3 to build, making our future Python 3
  compatibility story much easier while eliminating a large class
  of Python 2.7.2 and below bugs that we constantly found ourselves
  working around.</p>
</li>
<li>
<p>mach bootstrap has grown many new features and should be more robust
  than ever. There are numerous contributors here, including many
  community members that have found and fixed bugs and have added
  support for additional distributions.</p>
</li>
<li>
<p>The boilerplate from Makefile.in has disappeared. Mike Hommey is to
  thank.</p>
</li>
<li>
<p>dumbmake integrated with mach. Resulted in friendlier build interface
  for a nice UX win. Code by Nick Alexander. I reviewed.</p>
</li>
<li>
<p>Many variables have been ported from Makefile.in to moz.build. We
  started Q3 with support for 47 variables and now support 73. We
  started with 1226 Makefile.in and 1517 moz.build and currently
  have 941 Makefile.in and 1568 moz.build. Many people contributed to
  this work. Worth mentioning are Joey Armstrong, Mike Shal, Joshua
  Cranmer, and Ms2ger.</p>
</li>
<li>
<p>Many build actions are moving to Python packages. This enabled pymake
  <em>inlining</em> (faster builds) and is paving the road towards no .pyc
  files in the source directory. (pyc files commonly are the source of
  clobber headaches and make it difficult to efficiently perform builds
  on read-only filesystems.) I wrote most of the patches and Mike Shal
  and Mike Hommey reviewed.</p>
</li>
<li>
<p>moz.build is now more strict about what it accepts. We check for
  missing files at config parse time rather than build time, causing
  errors to surface faster. Many people are responsible for this work.
  Mike Shal deserves kudos for work around C/C++ file validation.</p>
</li>
<li>
<p>mach has been added to the B2G repo. Jonathan Griffin and Andrew
  Halberstadt drove this.</p>
</li>
</ul>
<h2>Current status of the build bystem</h2>
<p>Q3 was a very significant quarter for the build system. For the first
time in years, we made fundamental changes to how the build system
goes about building. The moz.build work to free our build config from
the shackles of make files had enabled us to consume that data and do
new and novel things with it. This has enabled improvements in build
robustness and - most importantly - speed.</p>
<p>This is most evident with the MOZ_PSEUDO_DERECURSE work, which
effectively replaces how make traverses directories. The work there
has allowed Gecko developers focused on libxul to go from e.g. 50s
no-op build times to less than 5s. Combined with optimized building
of XPIDL, IPDL, and WebIDL files, processing of file installs via
manifests, and C++ header dependency reduction, and a host of other
changes, and we are finally turning a corner on build times! Much of
this work wouldn't have been possible without moz.build files providing
a whole world view of our build config.</p>
<p>The quarter wasn't all roses. Unfortunately, we also broke things. A lot.
The total number of required clobbers this quarter grew slightly from
38 in Q2 to 43 in Q3. Many of these clobbers were regressions from
supposed improvements to the build system. Too many of these
regressions were Windows/pymake only and surely would have been found
prior to landing if more build peers were actively building on Windows.
There are various reasons we aren't. We should strive to fix them so
more build development occurs on Windows and Windows users aren't
unfairly punished.</p>
<p>The other class of avoidable clobbers mostly revolves
around the theme that <em>the build system is complicated</em>, particularly
when it comes to integration with release automation. Build automation
has its build logic currently coded in Buildbot config files. This means
it's all but impossible for build peers to test and reproduce that build
environment and flow without time-intensive, stop-energy abundant
excessive try pushes or loading out build slaves. The RelEng effort
to extract this code from buildbot to mozharness can't come soon enough. See
<a href="/blog/2013/07/16/analysis-of-firefox%27s-build-automation/">my overview</a>
on how automation works for more.</p>
<p>This quarter, the sheriffs have been filing bugs whenever a clobber is
needed. This has surfaced clobber issues to build peers better and I
have no doubt their constant pestering caused clobber issues to be
resolved sooner. It's a terrific incentive for us to fix the build
system.</p>
<p>I have mixed feelings on the personnel/contribution front in Q3. Kyle
Huey no longer participates in active build system development or patch
review. Ted Mielczarek is also starting to drift away from active coding
and review. Although, he does constantly provide knowledge and historical
context, so not all is lost. It is disappointing to see fantastic
people and contributors no longer actively participating on the coding
front. But, I understand the reasons behind it. Mozilla doesn't have a
build team with a common manager and decree (a mistake if you ask me).
Ted and Kyle are both insanely smart and talented and they work for
teams that have other important goals. They've put in their time (and
suffering). So I see why they've moved on.</p>
<p>On the plus side, Mike Hommey has been spending a lot more time on build
work. He was involved in many of the improvements listed above. Due to
review load and Mike's technical brilliance, I don't think many of our
accomplishments would have happened without him. If there is one
Mozillian who should be commended for build system work in Q3, it should
be Mike Hommey.</p>
<p>Q3 also saw the addition of new build peers. Mike Shal is now a full
build config module peer. Nick Alexander is now a peer of a submodule
covering just the Fennec build system. Aside from his regular patch
work, Mike Shal has been developing his review skills and
responsibilities. Without him, we would likely be drowning in review
requests and bug investigations due to the departures of Kyle and Ted.
Nick is already doing what I'd hope he'd do when put in charge of the
Fennec build system: looking at a proper build backend for Java (not
make) and Eclipse project generation. (I still can't believe many of
our Fennec developers code Java in vanilla text editors, not powerful
IDEs. If there is one language that would miss IDEs the most, I'd think
it would be Java. Anyway.)</p>
<p>There was a steady stream of contributions from people not in the build
config module. Joshua Cranmer has been keeping up with moz.build
conversions for comm-central. Nathan Froyd and Boris Zbarsky have helped
with all kinds of IDL work. Trevor Saunders has helped keep things
clean. Ms2ger has been eager to provide assistance through code and
reviews. Various community contributors have helped with moz.build
conversion patches and improvements to mach and the bootstrapper. Thank
you to everyone who contributed last quarter!</p>
<h2>Looking to the future</h2>
<p>At the beginning of the quarter, I didn't think it would be possible
to attain no-op build speeds with make as quickly as <em>make binaries</em> now
does. But, Mike Hommey worked some magic and this is now possible.
This was a game changer. The code he wrote can be applied to other
build actions. And, our other solutions involving moz.build files to
autogenerated make files seems to be working pretty well too.
This raises some interesting questions with regards to priortization.</p>
<p>Long term, we know we want to move away from make. It is old
and clumsy. It's easy to do things wrong. It doesn't scale to handle a
single DAG as large as our build system. The latter is particularly
important if we are to ever have a build system that doesn't require
clobbers periodically.</p>
<p>Up to this point we've prioritized work on moz.build conversion, with
the rationale being that it would more soon enable a clean break from
make and thus we'd arrive at drastically faster builds sooner. The assumption in that
argument was that drastically faster builds weren't attainable with
make. Between the directory traversal overhaul and the release of GNU
make 4.0 last week (which actually seems to work on Windows, making the
pymake slowness a non-issue), the importance of breaking away from make
now seems much less pressing.</p>
<p>While we would like to actively move off make, developments in the past
few weeks seem to say that we can reassess priorities. I believe that we
can drive down no-op builds with make to a time that satisfies many -
let's say under 10s to be conservative. Using clever tricks optimizing
for common developer workflows, we can probably get that under 5s
everywhere, including Windows (people only caring about libxul can
get 2.5s on mozilla-central today). This isn't the 250ms we could get
with Tup. But it's much better than 45s. If we got there, I don't think
many people would be complaining.</p>
<p>So, the big question for goals setting this quarter will be whether we
want to focus on a new build backend (likely Tup) or whether we should
continue with an emphasis on make. Now, a lot of the work involved
applies to both make and any other build backend. But, I have little
doubt it would be less overall work to support one build backend (make)
than two. On the other hand, we know we want to support multiple build
backends eventually. Why wait? In the balance are
<a href="https://etherpad.mozilla.org/build-system-goals">numerous other projects</a>
that have varying impact for developers and release automation. While
important in their own right, it is difficult to balance them against
build speed. While we could strive towards instantaneous builds, at some
point we'll hit <em>good enough</em> and the diminishing returns that accompany
them. There is already a small vocal faction advocating for Ninja
support, even though it would only decrease no-op libxul build times
from ~2.5s to 250ms. While a factor of 10x improvement, I think this is
dangerously close to diminishing returns territory and our time
investment would be better spent elsehwere. (Of course, once we can
support building libxul with Ninja, we could easily get it for Tup. And,
I believe Tup wins that tie.). Anyway, I'm sure it will be an
interesting discussion!</p>
<p>Whatever the future holds, it was a good quarter for the build system and
the future is looking brighter than ever. We have transitioned from a
maintain-and-react mode (which I understand has largely been the norm
since the dawn of Firefox) to a proactive and future-looking approach
that will satisfy the needs of Firefox and its developers for the next
ten years. All of this progress is even more impressive when you consider
that we still react to an aweful lot of fire drills and unwanted
maintenance!</p>
<p>The Firefox build system is improving. I'm as anxioux as you are to see
various milestones in terms of build speed and other features. But it's
hard work. Wish us luck. Please help out where you can.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Phabricator is Awesome]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/10/14/phabricator-is-awesome" />
    <id>http://gregoryszorc.com/blog/2013/10/14/phabricator-is-awesome</id>
    <updated>2013-10-14T11:00:00Z</updated>
    <published>2013-10-14T11:00:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Phabricator is Awesome]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/10/14/phabricator-is-awesome"><![CDATA[<p>When I talk to Mozillians who now work at Facebook, they all say
something similar: <em>the tools at Facebook are amazing and put what
Mozilla uses to shame</em>. Having worked at places with decent tools, I
do know that Mozilla is behind the times. So it was easy for me to
dismiss these observations as obvious. But, when you start asking them
about specifics, one tool they are quick to name is
<a href="http://phabricator.org/">Phabricator</a>.</p>
<p>For those who don't want to follow the link, Phabricator is your
all-in-on software engineering web application and platform. It has
issue/bug tracking, code review, repository navigation, wikis, etc. It's
the kitchen sink for software lifecycle management. And, it's open
source and easy to extend. Sounds promising.</p>
<p>After hearing Facebookers rave about Phabricator and having casually
interacted with an instance to review patches to Clang, I was keen
to have a closer look.</p>
<p>So, I spent a lazy afternoon and installed Phabricator on an EC2
instance (connection details below). Having interacted with the
default setup for a few hours, I can say with high confidence
that the Facebookers can back up their claim that Phabricator is
pretty damn amazing. My initial impressions are that it's one of
those tools that's so good that once you start using it, you'll
never tolerate anything subpar again. Again, hearing the
Mozillians-turned-Facebookers opine about Bugzilla, code review,
etc, I think this initial impression might be right.</p>
<p>In the sections below, I'll talk a bit about Phabricator and why I
think it is superior to what Mozilla uses.</p>
<h2>Integrated UI</h2>
<p>One thing I really love about Phabricator is the integrated UI.
Phabricator is essentially a collection of <em>applications</em> tied together
by a single web interface. So, everything is readily available under one
site/domain/service.</p>
<p>This means everything is easier to find. You search for something and
all the different components have their results surfaced. Contrast with
Mozilla as of today, where you need separate searches for Bugzilla,
MXR/DXR, wiki.mozilla.org, etherpad, MDN, etc.</p>
<p>For IT, it means there is only a single service to run and scale. Less
overhead to operate. Less effort to secure.</p>
<h2>Arcanist command line tool</h2>
<p>Phabricator ships with a command line tool called
<a href="http://www.phabricator.com/docs/phabricator/article/Arcanist_User_Guide.html">Arcanist</a>.
It is amazing.</p>
<p>Projects put <em>.arcconfig</em> files under version control which contain the
settings used to configure Arcanist for that project. They essentially
point back towards the Phabricator instance for that project.</p>
<p>You can do a lot with the Arcanism command line interface. Want to
create a code review? <em>arc diff</em>. It opens up an editor and allows you
to fill in details about the review. It then automatically publishes it
for review. No leaving the command line necessary.</p>
<p>You can download and apply patches undergoing code review by
specifying their review identifier. e.g. <em>arc patch D1</em>.</p>
<p>You can create tasks for yourself by running <em>arc todo</em>. The tasks are
uploaded to Phabricator automatically and show up in your dashboard.</p>
<p>If your repo has configured which tests apply to which paths, <em>arc unit</em>
will run all tests impacted by the current patch. (If we ever get around
to annotating this, it would significantly reduce load in automation by
eliminating unnecessary tests.)</p>
<p>There is an <em>arc land</em> command to land patches on the appropriate
landing branch.</p>
<p>Arcanist abstracts the differences between version control systems
pretty well. You can use the same commands for Mercurial, Git, or
Subversion.</p>
<p>Arcanist is pretty nice. It reminds me a lot of mach and what I
originally wanted mach to become with regard to helping to improve
developer workflow.</p>
<h2>Real Code Review</h2>
<p>Phabricator features a real code review tool -
<a href="http://www.phabricator.com/docs/phabricator/article/Differential_User_Guide.html">Differential</a>.</p>
<p>Things like interdiff actually work. It integrates with the code
repository, which means you can expand context right from the
review interface. It can detect blocks
of code that moved between files. It has a nice file tree for navigating
changed files (optional feature). It hides whitespace only changes by
default. You can specify a group of people for review and reviews will
show up in the dashboard of individuals in that group. It has a flag
to say whether a patch underwent <em>linting</em> before upload. (You can
configure linting through Arcanist and have your patches linted before
upload. If you properly deploy linting, style nits all but go away. As I
like to say, every time I write a style nit in code review, my time is
wasted and Mozilla is throwing away part of my salary.)</p>
<p>Mozilla is apparently integrating ReviewBoard into Bugzilla. This is
good. ReviewBoard's review features are infinitely better than Splinter
(Bugzilla's current review interface). However, ReviewBoard is mostly a
standalone tool. What makes Phabricator's approach better is that code
review integrates tightly with everything else. This enables some pretty
awesome scenarios. Keep reading for more.</p>
<h2>Auditing</h2>
<p>An interesting and potentially very useful feature of Phabricator is
<a href="http://www.phabricator.com/docs/phabricator/article/Audit_User_Guide.html">auditing</a>.
Where Differential handles pre-push code review, the Audit
application supports post-push code review. You may say <em>but all changes
at Mozilla must go through pre-push code review - there's no use for
post-push code review</em>. Yes, but post-push review opens up a whole new
realm of possibilities.</p>
<p>It's possible for individual users or projects to set up rules to
automatically trigger audits. For example, as build module owner, I'm
very interested in ensuring people follow the code review policy of
having a build peer review changes to make files. With Phabricator, I
was able to easily configure a rule that automatically creates an audit
every time a make file has changed but it wasn't signed off by a build
peer. Front and center on my dashboard are a list of commits that I
should probably look at. Neat!</p>
<p>Audits are potentially useful for reviews that focus less on code. For
example, Firefox Health Report and Telemetry are two Firefox features
that collect data and send it (anonymously) to Mozilla. Audits could be
used to flag a privacy review when probes are changed. We often don't
want this privacy review to hold up code landing. But we do want to
track that this review occurs before a patch is shipped to our Beta
channel users. I think audits would be great for facilitating this.</p>
<p>Of course, there is a web interface to create new audits. Any individual
can watch anything they have access to. No process involved. Just log in
and create a rule.</p>
<p>Mozilla has audits today, but it isn't user intuitive. They commonly
take the form of Bugzilla keywords or whiteboard entries. Phabricator's
feature is much more powerful.</p>
<h2>Creating rules as a result of actions</h2>
<p>Phabricator has an application called <em>Herald</em> that allows users to
install rules to do something as a result of an action.</p>
<p>For example, I can create a rule against new review requests that will
CC me or automatically add me as a reviewer if a certain file is touched
by a patch.</p>
<p>I can have Phabricator email me whenever a specific user makes a commit
or when a commit touching a specific file is made.</p>
<p>This feature is self-service. You just open the web interface and
program custom rules to your heart's content.</p>
<p>Herald is insanely useful. To my knowledge, Mozilla has nothing quite
like it today. I wish we did. If Mozilla doesn't official deploy
Phabricator, I may continue to run my own personal instance just so I
can have this feature.</p>
<p>Of course, there's an
<a href="http://www.phabricator.com/docs/phabricator/article/Events_User_Guide_Installing_Event_Listeners.html">Event Listener API</a>
so you can write your own events and rules. The sky is literally the
limit here. For example, we could have all uploaded patches
automatically submitted to Try so they run the release automation
gamut. And, we could have Phabricator's background daemons poll for try
results and report them directly in the web interface!</p>
<h2>Module ownership defined inside Phabricator</h2>
<p>Phabricator has a <em>modules</em> concept built into it called
<a href="http://www.phabricator.com/docs/phabricator/article/Owners_Tool_User_Guide.html">Owners</a>. You
create a <em>package</em> that has a single owner and a number of members. This
package can be associated with multiple repositories and individual
paths inside repositories.</p>
<p>The power of this feature is realized when it is integrated with other
components of Phabricator.</p>
<p>For example, there is a checkbox for each <em>package</em> where you can
automatically have Phabricator ensure that a package member is involved
with code review touching files belonging to a package. It will also
automatically report commits not reviewed by members of a package. How
insanely useful is that!</p>
<h2>Other applications and features.</h2>
<p>Phabricator ships with a number of other applications and features.</p>
<p>There's a blogging platform called
<a href="http://www.phabricator.com/docs/phabricator/article/Phame_User_Guide.html">Phame</a>.</p>
<p>There's a simple wiki called
<a href="http://www.phabricator.com/docs/phabricator/article/Phriction_User_Guide.html">Phriction</a>.</p>
<p>There's a simple polling application called
<a href="http://www.phabricator.com/docs/phabricator/article/Slowvote_User_Guide.html">Slowvote</a>.</p>
<p>There's a mechanism to upload and view files.</p>
<p>There's a pastebin-like application called Paste. It integrates with
authentication and authorization, so you can limit the audience of
pastes.</p>
<p>There's a JSON over HTTP API that allows you to do nearly everything.
(I assume this is what Arcanist uses for everything.)</p>
<p>There's a built-in badges mechanism called Tokens.</p>
<p>You can exchange messages and chats with other users (similar to IRC)
using Conpherence.</p>
<p>There is a question and answer application called Ponder. People ask
questions and other people answer them. You can search questions, of
course. This helps build up a searchable knowledge base.</p>
<p>There is a mockups viewing and collaboration tool called Pholio. You can
upload mockups as photos and then annotate images through the web
interface. e.g. you can create a rectangle and ask a question about what
you see in that rectangle.</p>
<p>There is a time tracking application called Phrequent.</p>
<p>Phabricator can receive inbound email to update issues, reviews, etc.
You can even file new bugs via email! Having used an email interface to
Bugzilla at a previous job, I can say from experience this is extremely
useful.</p>
<p>Phabricator allows you to cherry pick which applications you have
enabled. Want just code review and repository browsing without issue
tracking? You can do that.</p>
<h2>Test instance for Mozilla</h2>
<p>As I alluded to above, I have installed an instance of Phabricator on
EC2. My intention for this instance is for Mozillians to start playing
with it and seeing if it's something they'll like.</p>
<p>The test instance is available at
<a href="http://phabricator.gregoryszorc.com/">http://phabricator.gregoryszorc.com/</a>.</p>
<p>You can log in using OAuth with one of the configured service providers
or by creating an account. Please note that I'm only serving on plain
HTTP, so your password are sent in the clear.</p>
<p>I have configured a few popular Mozilla repositories with the install.
It's easy to configure new repositories. Send me their info and I'll add
them!</p>
<p>While the web UI is nice, Arcanist is essential to get the most out of
Phabricator. To get <em>arc</em> working with your machine, follow the
<a href="http://www.phabricator.com/docs/phabricator/article/Arcanist_Quick_Start.html">official instructions</a>
to install Arcanist. For your <em>.arcconfig</em> file, use something like:</p>
<pre><code>{
  "project_id": "gecko",
  "conduit_uri": "http://phabricator.gregoryszorc.com/"
}
</code></pre>
<p>Then, have Arcanist fetch authentication credentials:</p>
<pre><code>$ arc install-certificate
</code></pre>
<p>From there, run <em>arc help</em> and see what you can do!</p>
<p>Of course, you'll need to adjust the <em>project_id</em> when appropriate.</p>
<p>When you use this Phabricator instance, please keep the following in
mind:</p>
<ul>
<li>I'm hosting this on my own dime and have the most powerful EC2
  instance I felt like paying out of pocket. That instance sadly isn't
  powerful enough. I installed Phabricator on my desktop at home and it
  flies like a rocket ship. Please don't blame slowness on Phabricator.</li>
<li>I didn't even attempt to tune the HTTP or MySQL servers yet. Expect
  more slowness.</li>
<li>The service and all the data inside could go away at any time. I don't
  have monitoring of the service (yet). <strong>Use at your own risk.</strong></li>
<li>At the time I wrote this, Phabricator was still indexing some
  repositories, notably mozilla-central. Anything interacting with
  source navigation appears to be slow as a result.</li>
<li>The install is effectively a vanilla, out-of-the-box install. Things
  like Mozilla styling could presumably be added. There are likely also
  many sub-par configuration settings. Leave comments and I'll see about
  changing things.</li>
<li>The front page insists on a sign-in. However, I believe all of the
  content should be accessible to the public. Contact me if you know of
  a way to fix this!</li>
<li>This could be hooked up with Persona. I couldn't find a Persona auth
  provider and coding one is beyond my current PHP skills. If someone
  writes one, let me know and I'll install it!</li>
<li>I could hook up authentication against Mozilla's LDAP server. However,
  I don't want your Mozilla credentials going to my personal server nor
  traveling over the wire in the clear.</li>
<li>I'm not an expert on Phabricator. I'll try to help where appropriate.
  But don't count on me being a support desk.</li>
</ul>
<h2>Next steps at Mozilla</h2>
<p>How should we use Phabricator at Mozilla? Good question!</p>
<p>I encourage people to play around with my personal instance. Upload some
patches. Perform some code reviews. Set up Herald rules to notify you of
repository change events. Just keep in mind that I don't guarantee an
SLA for my instance. So please don't rely on it.</p>
<p>I anticipate that people will come to the conclusion that Phabricator is
awesome and that Mozilla should install an officially supported instance
on a mozilla.org domain with proper hardware. I'll likely be reaching
out to IT shortly to see how feasible that is. But, I imagine it will
get shuffled to the bottom of the priority queue unless people make
noise. If you like Phabricator, tell other people about it. Let your
management chain know how amazing it is. If enough of or the right
people clamor for it, priorities can get changed.</p>
<p>I hope you enjoy Phabricator!</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Why Firefox builds are slow]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/10/01/why-firefox-builds-are-slow" />
    <id>http://gregoryszorc.com/blog/2013/10/01/why-firefox-builds-are-slow</id>
    <updated>2013-10-01T01:30:00Z</updated>
    <published>2013-10-01T01:30:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Why Firefox builds are slow]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/10/01/why-firefox-builds-are-slow"><![CDATA[<p>Many people ask/complain about Firefox builds being slow. They are slow.
You have every right to complain.</p>
<p>Now in the <a href="https://ci.mozilla.org/job/mozilla-central-docs/Build_Documentation/index.html">official build system docs</a>
is a <a href="https://ci.mozilla.org/job/mozilla-central-docs/Build_Documentation/slow.html">page</a>
explaining the major reasons why the build system is slow. I encourage
everyone to read it. If you have any questions, ping me and I'll update
the docs.</p>
<p>Not yet documented there are some new insights we've been getting from
Mike Hommey's <a href="https://groups.google.com/d/msg/mozilla.dev.platform/4dp9WTQ6F60/9ypVOMk55zkJ">terrific work</a>
to optimize how make traversal works in the current build system.</p>
<p>As part of that work, Mike established a new <em>compile</em> tier in the build
system. This tier compiles C/C++ and little else. Before, C/C++
compiling was interleaved with all the other build steps (install JS
files, xpt processing, etc), so it was somewhat difficult to isolate the
impact of compilation against all other build actions.</p>
<p>Now that we have all compiling happening in one isolated phase, it's pretty
obvious that compiling accounts for the majority of CPU and wall time in
the build system (at least with non no-op builds). We suspected this
before, but we didn't have concrete numbers.</p>
<p>As I've been pulling and rebuilding inbound since this change landed,
it's become increasing clear to me the impact of header dependency hell
on build times. Even simple changesets touching a few .h files are
resulting in hundreds or even thousands of C/C++ files being recompiled.
This increases incremental build times from say 1.5 minutes to often
over 10 minutes.</p>
<p>With Mike Hommey's work, I feel we finally are on a path to make no-op
build times reasonable for many developers. However, until the header
dependency graph is significantly reduced, developers will continue to
see excessively long build times for incremental builds, especially on
pulls. (I notice that my daily inbound pulls take about as long as a
clobber build, which means practically every .cpp file is invalidated
every day due to .h changes.)</p>
<p>Fortunately, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=785103">great work</a>
has been happening to minimize C/C++ header dependency hell recently.
To everyone working on that, everyone who builds Firefox owes you a
giant <strong>thank you</strong>. However, there's much more that can be done. While
you've made terrific progress, please don't slow down any time soon.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Important Ubuntu bootstrap update]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/09/12/important-ubuntu-bootstrap-update" />
    <id>http://gregoryszorc.com/blog/2013/09/12/important-ubuntu-bootstrap-update</id>
    <updated>2013-09-12T09:35:00Z</updated>
    <published>2013-09-12T09:35:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Important Ubuntu bootstrap update]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/09/12/important-ubuntu-bootstrap-update"><![CDATA[<p>Do you run Ubuntu and build Firefox? If so, please check out a
mozilla-central revision as of a few hours ago and run <strong>mach
bootstrap</strong>. Among other things, the bootstrapper now installs a modern
version of Mercurial (2.7 at the time I wrote this). Ubuntu currently
ships 2.2.2 in 12.10 and 13.04. It's even worse for older releases.
Mercurial has evolved a lot over the last few months and releases and
I don't think you'll be disappointed after upgrading.</p>
<p>If you don't run Ubuntu, you should still run <strong>mach bootstrap</strong>
periodically to ensure your system has the optimal packages for
developing Firefox.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Hosting Mozilla services with Stackato]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/09/04/hosting-mozilla-services-with-stackato" />
    <id>http://gregoryszorc.com/blog/2013/09/04/hosting-mozilla-services-with-stackato</id>
    <updated>2013-09-04T15:07:00Z</updated>
    <published>2013-09-04T15:07:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Hosting Mozilla services with Stackato]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/09/04/hosting-mozilla-services-with-stackato"><![CDATA[<p>Many people have written custom web services related to Mozilla
projects. Cool! However, many of these services live on random hosts
scattered around the internets. These hosts can have frequent downtime,
cost Mozilla contributors time and money to operate, and can be hard to
discover and trust (I don't want to give my LDAP credentials to a
non-Mozilla server).</p>
<p>Did you know Mozilla operates a Platform-as-a-Service (PaaS)
infrastructure that allows Mozillians to host web services and daemons
on the internets (similar to how EC2 works). Until recently, I didn't
either!</p>
<p>If you are a Mozilla employee, learn more about
<a href="https://mana.mozilla.org/wiki/display/websites/paas.allizom.org">paas.allizom.org</a>.
(To non-employees, unfortunately it appears you can't use this yet. And
I'm not sure what the plans for that are.)</p>
<p>This service is actually a Mozilla-hosted <a href="http://www.activestate.com/stackato">Stackato</a>
instance. You set up your client with your LDAP credentials, provision
services such as PostgreSQL, memcache, MySQL, etc and deploy
applications - either web applications or standalone daemons. The
runtime environment supports nearly everything under the sun - Python,
Node.js, Ruby, Perl, PHP, Java, etc. You write an application, drop a
few files in the project to describe how to deploy it to Stackato, push
it, and <em>it just works.</em> Web applications even get an HTTPS endpoint
with a valid root CA chained certificate!</p>
<p>I recently used this service to power my Django-based
<a href="https://hg.mozilla.org/users/gszorc_mozilla.com/automation-dashboard/">automation-dashboard</a>
project. Aside from the initial hurdles figuring out how Django works
(this was the first Django project I've written) and how to hook Django
up to Stackato, I'm pretty impressed with the results. Free web hosting
with database access!</p>
<p>For me, the selling point of this service is that apparently the
transition plan from Stackato-hosted service to IT-managed service is
relatively pain free. Since you must perform all the steps to
isolate/package your application for Stackato, it's relatively easy for
IT to deploy your application.</p>
<p>I encourage Mozillians to look into using this PaaS service for their
Mozilla service hosting needs.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Visualizing Mozilla's release infrastructure machine efficiency]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/08/30/visualizing-mozilla's-release-infrastructure-machine-efficiency" />
    <id>http://gregoryszorc.com/blog/2013/08/30/visualizing-mozilla's-release-infrastructure-machine-efficiency</id>
    <updated>2013-09-03T12:15:00Z</updated>
    <published>2013-08-30T12:30:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Visualizing Mozilla's release infrastructure machine efficiency]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/08/30/visualizing-mozilla's-release-infrastructure-machine-efficiency"><![CDATA[<p>Have you ever wondered what the machines in Mozilla's automation
infrastructure are doing all the time? I have. So, I decided to create a
visualization of this data. You can find it at
<a href="http://automation-dashboard.paas.allizom.org/">http://automation-dashboard.paas.allizom.org/</a>.</p>
<p>When you start looking at the visualizations, you notice something:
there's a lot of time when machines aren't doing anything! All that
white space between jobs is time machines are not processing jobs. This
is capacity Mozilla is failing to utilize.</p>
<p>While some may say Mozilla's automation infrastructure has a load or
capacity problem, I say it has an efficiency problem. The average
machine in our automation infrastructure is doing work less than 50% of
the time <em>during weekdays</em>. Now, some of this might be VMs that are
powered off (due to low demand). But considering physical machines are
also under-utilized, I'd say it's a global problem.</p>
<p>Oh, and don't get too hung up with a machine-job efficiency metric.
While important, it's only part of the problem. When jobs are running,
they are typically only using a fraction of the CPU available to them.
From data <a href="/blog/2013/07/14/quantifying-mozilla's-automation-efficiency/">now available in mozharness</a>,
we know that many test suites only use 10-15% CPU. If you combine this
with sub-50% machine utilization in terms of jobs, I estimate we're only
utilizing somewhere between 5-10% of available CPU cycles in our automation
infrastructure. We have a magnitude more capacity in the machines we
already have. <strong>We don't have a capacity problem, we have an efficiency
problem.</strong> In my opinion we should throw less time and money at new
hardware and invest in maximizing the return from what we have.</p>
<h2>Edit 2013-09-03</h2>
<p>I started a thread about this data in another forum and others have
pointed out that the data in this post is incomplete. Notably absent
from this data is when on-demand EC2 instances are shut down, when there
are or aren't jobs scheduled (if jobs aren't scheduled, poor machine
utilization isn't such a big deal), and when some maintainence tasks are
performed (e.g. Panda boards are checked for consistency between jobs).
While we could probably hook job scheduling data up to the graph and
numbers easily, I don't believe data on slave <em>uptime</em> or background
tasks is publicly available. Perhaps we should publish this data to
facilitate deeper analysis.</p>
<p>A goal of this post was to shed light on how little we utilize some of
the machines in our automation infrastructure in order to inspire a
conversation and ultimately to address the perceived problem. It was
not a goal to point fingers and cast blame. If I inadvertently
performed the latter or seemed to jump to conclusions based on
incomplete data, I apologize.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Mercurial setup wizard for Firefox development]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/07/29/mercurial-setup-wizard-for-firefox-development" />
    <id>http://gregoryszorc.com/blog/2013/07/29/mercurial-setup-wizard-for-firefox-development</id>
    <updated>2013-07-29T17:45:00Z</updated>
    <published>2013-07-29T17:45:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Mercurial setup wizard for Firefox development]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/07/29/mercurial-setup-wizard-for-firefox-development"><![CDATA[<p>I'm a big fan of tools that encourage and/or enforce the following of
best practices and that help people become more productive.</p>
<p>One of the tools that Firefox developers interact with nearly daily is
Mercurial. As I've observed from coworkers and from community
contributors, many don't have Mercurial configured for optimal
development. For first-time contributors, this can manifest in patch
rejection - an experience that can be embarassing and demotivating. This
is frustrating to me because most issues are easily identifiable and
correctable. And, when addressed, everyone wins.</p>
<p>Anyway, I'm pleased to announce that there is now a configuration wizard
in the Firefox source tree to help with configuring Mercurial. To run it,
just type:</p>
<pre><code>./mach mercurial-setup
</code></pre>
<p>Currently, it's aimed for first-time contributors. So, it's missing
things that more seasoned developers rely on. But you need to start
somewhere, right?</p>
<p>Currently, the tool isn't advertised anywhere other than <em>mach help</em>.
Please run it and report issues in
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=794580">bug 794580</a> or
file a new report. Once things have baked in, I'd like to add some kind
of notification/tips system to mach where it will encourage you to do
things like automatically run <em>mach mercurial-setup</em>. Until then, I
recommend trying to remember to run <em>mach mercurial-setup</em> every few
weeks to ensure your Mercurial environment is up to date and properly
configured.</p>
<p>I'd like to thank Nick Alexander for sharing my enthusiasm for helping
contributors and for taking the time to review this work.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Track pushes and train riding with Mercurial]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/07/25/track-pushes-and-train-riding-with-mercurial" />
    <id>http://gregoryszorc.com/blog/2013/07/25/track-pushes-and-train-riding-with-mercurial</id>
    <updated>2013-07-25T13:10:00Z</updated>
    <published>2013-07-25T13:10:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Track pushes and train riding with Mercurial]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/07/25/track-pushes-and-train-riding-with-mercurial"><![CDATA[<p>My <a href="https://hg.mozilla.org/users/gszorc_mozilla.com/hgext-gecko-dev">Mercurial extension for Firefox development</a>
now has an initial implementation of pushlog aggregation and searching.</p>
<p>You first start by synchronizing the pushlog data on Mozilla's servers
with the local client:</p>
<pre><code>hg pushlogsync
</code></pre>
<p>This takes a while the first time you run it because it has to download
all the data. On subsequent runs, it only downloads new data, so it
should be much faster.</p>
<p>Then, you can search for the push history of a changeset:</p>
<div class="pygments_murphy"><pre>$ hg changesetpushes -a b968708558b9
133967:b968708558b9 Bug 839809:  Make counter-increments and list counting that would go past our internal (int32_t) limit keep the counter at its current value rather than wrapping.  r=dholbert

Per CSS WG resolution regarding counter-styles-3, afternoon of 2013-02-05:
http://krijnhoetmer.nl/irc-logs/css/20130205#l-1590
http://lists.w3.org/Archives/Public/www-style/2013Feb/0392.html

Note that this patch depends on signed integer overflow behavior in C++,
which I believe is portable despite being unspecified.
Tree      Date                Username              Build Info
inbound   2013-02-21T18:12:57 dbaron@mozilla.com    https://tbpl.mozilla.org/?tree=Mozilla-Inbound&amp;rev=85b91048c1cd
central   2013-02-22T09:43:12 ryanvm@gmail.com      https://tbpl.mozilla.org/?tree=Mozilla-Central&amp;rev=3a7d4085787e
build     2013-02-22T14:31:42 gszorc@mozilla.com    https://tbpl.mozilla.org/?tree=Build-System&amp;rev=3a7d4085787e
fx-team   2013-02-25T01:04:44 ttaubert@mozilla.com  https://tbpl.mozilla.org/?tree=Fx-Team&amp;rev=31466fd86eb7
graphics  2013-02-25T20:02:57 mwoodrow@mozilla.com  https://tbpl.mozilla.org/?tree=Graphics&amp;rev=dcf53b7140cd
ash       2013-02-26T13:50:41 armenzg@mozilla.com   https://tbpl.mozilla.org/?tree=Ash&amp;rev=201b64ad48d8
services  2013-02-28T09:42:45 Ms2ger@gmail.com      https://tbpl.mozilla.org/?tree=Services-Central&amp;rev=31466fd86eb7
aurora    2013-04-01T13:50:56 bbajaj@mozilla.com    https://tbpl.mozilla.org/?tree=Mozilla-Aurora&amp;rev=60a3f369ccf0
beta      2013-05-13T09:59:38 lsblakk@mozilla.com   https://tbpl.mozilla.org/?tree=Mozilla-Beta&amp;rev=60a3f369ccf0
release   2013-06-17T15:53:19 akeybl@mozilla.com    https://tbpl.mozilla.org/?tree=Mozilla-Release&amp;rev=c54e3363712e
</pre></div>

<p>(The <em>-a</em> argument prints all trees instead of just the release trees).</p>
<p>I'd like to integrate bug tracking into the mix to facilitate
answering questions like <em>when did bug 123456 ride the trains</em>.</p>
<p>I'd also like to integrate release versions and build IDs into the mix.
For example, when I look up a changeset, I want to know the first build
on the Nightly, Aurora, Beta, and Release channels that change was
included in.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Mercurial Extension for Gecko Development]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/07/22/mercurial-extension-for-gecko-development" />
    <id>http://gregoryszorc.com/blog/2013/07/22/mercurial-extension-for-gecko-development</id>
    <updated>2013-07-22T10:27:00Z</updated>
    <published>2013-07-22T10:27:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Mercurial Extension for Gecko Development]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/07/22/mercurial-extension-for-gecko-development"><![CDATA[<p>My weekend was spent hacking on Mercurial extensions. First, I worked on
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=827123">porting the pushlog extension off SQLite</a>.
This will eventually enable Mozilla to move Mercurial hosting off NFS
and should make <a href="https://hg.mozilla.org/">hg.mozilla.org</a> much faster as
a result!</p>
<p>But the main purpose of this blog post is to introduce a new Mercurial
extension I wrote this weekend!</p>
<p>Gecko developers perform a number of common tasks with Mercurial, so I
thought it would be handy to package them up in an extension.</p>
<p>To install the extension:</p>
<pre><code>hg clone https://hg.mozilla.org/users/gszorc_mozilla.com/hgext-gecko-dev
</code></pre>
<p>Then add this extension to your hgrc file (either the global or
per-repository will suffice):</p>
<pre><code>[extensions]
mozext = /path/to/hgext-gecko-dev
</code></pre>
<p>Since I believe tools should be self-documenting, run the following for
usage info:</p>
<pre><code>$ hg help mozext
</code></pre>
<p>Here are some examples:</p>
<div class="pygments_murphy"><pre><span class="c"># Clone mozilla-central into the mc directory.</span>
hg clone central mc
hg clone mc mc

<span class="c"># Create a unified Mercurial repository containing changesets</span>
<span class="c"># from all the release repositories.</span>
hg cloneunified gecko

<span class="c"># Pull changes from the central and inbound repositories.</span>
hg pull central
hg pull inbound

<span class="c"># Update the working tree to the tip of inbound.</span>
hg up inbound/default

<span class="c"># View the tree open/closed status.</span>
hg treestatus

<span class="c"># Show a list of all known trees and their aliases.</span>
hg moztrees

<span class="c"># Open TBPL for the push containing a changeset.</span>
hg tbpl inbound 821e984ef423
hg tbpl inbound inbound/default

<span class="c"># Push the tip of inbound to mozilla-central</span>
hg pushtree -r inbound/default central
</pre></div>

<p>I've only tested this extension with Mercurial 2.6 (which every Mozilla
developer should be running). I'm not willing to support older versions.
Upgrade already!</p>
<p>There are a number of features I'd like to implement:</p>
<ul>
<li><strong>hg importtry</strong> - Automatically import changesets for a Try push into
  the repository.</li>
<li><strong>hg land</strong> - Automatically land patches on an integration tree (like
  inbound). Will handle rebasing automatically.</li>
<li><strong>hg critic</strong> - Perform stlye checking and other analysis on a
  changeset or group of changesets.</li>
<li>Ability to integrate build status into changeset info. This will allow
  things such as <em>pull only the last green changeset</em>. I'd also like a
  <em>build status</em> field to appear in the log output. Unfortunately, I
  believe the latency of the build lookup API is prohibitively high to
  perform the kind of tight integration I'd like.</li>
<li>Move <em>mozautomation</em> Python package into a standalone package or
  integrate already existing code (did I reinvent the wheel?).</li>
<li>Log fetching. Specify a changeset and fetch build/test logs.</li>
<li>Possibly move code into mozilla-central.</li>
<li>Possibly add mach commands for some of this functionality.</li>
</ul>
<p>There's no bug component for this extension (yet). If you find any
issues or wish to add a feature, just email a patch to me at gps@mozilla.com.</p>
<p>Please let me know if you find this useful or if you have any questions.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Analysis of Firefox's Build Automation]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/07/16/analysis-of-firefox's-build-automation" />
    <id>http://gregoryszorc.com/blog/2013/07/16/analysis-of-firefox's-build-automation</id>
    <updated>2013-07-16T18:15:00Z</updated>
    <published>2013-07-16T18:15:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Analysis of Firefox's Build Automation]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/07/16/analysis-of-firefox's-build-automation"><![CDATA[<p>Mozilla operates thousands of machines whose sole role is to build
Firefox (and related applications), run tests, perform static analysis,
etc. This is collectively referred to as the <em>Firefox/Mozilla build
automation</em> or just <em>automation</em>. The output of all this automation
can be seen at <a href="https://tbpl.mozilla.org/">tbpl.mozilla.org</a>.</p>
<p>In this post, I'll give an overview of how all this automation works
followed by a critical analysis identifying what I like and what I
feel should be improved.</p>
<h2>How Firefox automation works</h2>
<p>Let's take a journey through what happens when you push a new revision
of <a href="https://hg.mozilla.org/mozilla-central/">mozilla-central</a> (the main
Firefox repository) to Mozilla's canonical Mercurial server. (For
Mozilla people, this journey is roughly the same regardless of which
automation-enabled project branch you push to.) While Firefox's
automation infrastructure kicks off builds on
<a href="https://tbpl.mozilla.org/">several platforms and operating systems</a>,
for simplicity reasons, I'm going to limit low-level technical details
to our 64-bit Linux builds.</p>
<p>Before I begin, a disclaimer: I'm not a subject expert in much of
what I'm about to say. There are people who spend a magnitude more time
than myself touching the systems I'm about to describe. If I get
something wrong, please contact me and I'll update this post.</p>
<p>Let's begin.</p>
<h3>Buildbot</h3>
<p>The heart of Firefox's build automation is a piece of software called
<a href="http://buildbot.net/">Buildbot</a>. Buildbot is essentially a glorified
job scheduling system. I find the
<a href="http://buildbot.net/#/basics">buildbot basics</a> covers, well, the basics
pretty well. What you need to know is that Mozilla maintains a
<a href="https://hg.mozilla.org/build/buildbot/">buildbot repository</a> that
appears to contain the buildbot core plus basic customization for
Mozilla.</p>
<p>There are buildbot <em>masters</em> and <em>slaves</em>. <em>masters</em> do all
the coordination and scheduling; <em>slaves</em> do all the real work (such as
compiling Firefox). Mozilla operates a handful of masters and a few
thousand slaves.</p>
<p>When you push code to a project branch (like <em>mozilla-central</em>), a
buildbot master sees the push then figures out what needs to happen. For
<em>mozilla-central</em>, the push gets translated to a request to build on
several different platforms. These requests then go to a scheduler
(possibly getting collapsed into a single request). These requests then
get turned into jobs that run on slaves.</p>
<p>This logic mostly lives in the
<a href="https://hg.mozilla.org/build/buildbot-configs/">buildbot-configs repository</a>.
Of particular interest is the
<a href="https://hg.mozilla.org/build/buildbot-configs/file/e8b27b8b7216/mozilla/config.py">config.py</a>
file, which pretty much defines how buildbot is configured at Mozilla -
at a high-level anyway.</p>
<p>When a scheduled job executes, the high-level job request is converted into
low-level actions (or <em>steps</em> in buildbot parlance) that get executed on
slaves. For example, a request to build might clone the source
repository, run client.mk, package the results, etc. This logic lives
in the
<a href="https://hg.mozilla.org/build/buildbotcustom/">buildbotcustom repository</a>.
It's worth highlighting the
<a href="https://hg.mozilla.org/build/buildbotcustom/file/bdcca6f7b6c2/process/factory.py">factory.py</a> file. This file contains the beef of the logic
for converting high-level jobs into actions on slaves. Start at the
<a href="https://hg.mozilla.org/build/buildbotcustom/file/bdcca6f7b6c2/process/factory.py#l379">MozillaBuildFactory class</a>
class to see exactly what goes into performing a build. Then move on to
<a href="https://hg.mozilla.org/build/buildbotcustom/file/bdcca6f7b6c2/process/factory.py#l1338">addDoBuildSteps()</a>,
which contains the command for invoking the actual build system. As you
can see, there's a lot that goes into building besides just invoking the
build system (like most developers do)!</p>
<p>For many automation jobs, there is an additional component that comes
into play: <a href="https://hg.mozilla.org/build/mozharness/">mozharness</a>.
<em>mozharness</em> is relatively new to the Firefox build automation
landscape so you may not be familiar with it. A goal of <em>mozharness</em> is
to largely migrate the low-level logic from <em>buildbotcustom</em> - the logic
that converts a high-level job request into low-level buildbot <em>steps</em>
(typically command invocations) - into a separate, standalone entity
that doesn't depend on buildbot. A goal is to enable developers to run
mozharness locally and run automation jobs just like the official
automation infrastructure does. If you have time, I encourage you to
read the
<a href="https://developer.mozilla.org/en-US/docs/Mozharness_FAQ">mozharness FAQ</a>
to learn more. My understanding is <em>mozharness</em> will eventually power
<strong>all</strong> of the jobs currently defined in <em>buildbotcustom</em>, so I
recommend getting acquainted with <em>mozharness</em>.</p>
<p>In the <em>mozharness</em> world, automation jobs are defined as <em>scripts</em>.
Here's the
<a href="https://hg.mozilla.org/build/mozharness/file/84187194b050/scripts/marionette.py">marionette script</a>.
You just execute a script (with ideally as few arguments as possible)
and <em>mozharness</em> does the rest. In buildbot, instead of having a job
with say 12 steps and this logic for configuring the steps live in
buildbot, buildbot just says <em>run the marionette mozharness script</em>.
Since very little business logic now lives in buildbot, this essentially
reduces buildbot's role to just job scheduling.</p>
<p>And that is essentially how the automation determines what to run. Now
let's talk about the machines automation runs on.</p>
<h3>Machine provisioning</h3>
<p>Earlier, I said Mozilla operates thousands of buildbot slaves. Let's
talk about how those slaves come into existence.</p>
<p>A slave is just a fancy name for a machine, either physical or virtual.
These machines are owned or operated by Mozilla. Mozilla either buys
a physical machine or rents one from a <em>cloud provider</em>, like Amazon
EC2.</p>
<p>For hopefully obvious reasons, it is important for the configuration of
these machines to be consistent. Let's talk about how that is done. Keep
in mind I'm talking about Linux machines. OS X and Windows machines go
through a different procedure.</p>
<p>When a new machine is acquired, it needs an operating system. There is a
<a href="https://hg.mozilla.org/build/puppet/file/6f7b4a33af2c/setup/centos6-kickstart.cfg.erb">kickstart config file</a>
that installs CentOS 6.2. At the end of the base OS flash/install, it
configures Puppet to talk to a central Puppet master. This Puppet
infrastructure is called
<a href="https://wiki.mozilla.org/ReleaseEngineering/PuppetAgain">PuppetAgain</a>
and its files are stored in the
<a href="https://hg.mozilla.org/build/puppet/">puppet repository</a>.</p>
<p>Puppet is let loose on the fresh OS install and eventually the machine
is configured so it is homogenous with other similar machines in the
automation infrastructure. Presumably, Puppet continually polls the
central Puppet master and applies the latest configuration.</p>
<p>Part of the <em>puppetization</em> of this machine involves installing the
buildbot client. The client eventually registers with the buildbot
master and waits for jobs to process.</p>
<p>So, we've described how machines are provisioned as buildbot slaves and
how buildbot jobs are converted to actions/steps/commands to be
performed on slaves. Let's examine a job in more detail.</p>
<h3>Running a build job</h3>
<p>Before I talk about the details of a build job, it's worth mentioning
that nearly everything I described up until this point is largely hidden
from view from most Firefox developers. As far as I know, things like
Puppet logs are hidden from public view. And there shouldn't be anything
terribly wrong with that: the Puppet configs are public, after all.
Unless you are affiliated with Release Engineering or the Automation and
Tools Team (A*Team) or hack on a component that warrants its own piece
of automation, you probably aren't too concerned with how all of this
works.</p>
<p>Anyway, it's finally time to start talking about something almost every
Firefox developer has done: build Firefox from source.</p>
<p>As I mentioned above, code in <em>buildbotcustom</em> (to be replaced by
<em>mozharness</em> someday) is responsible for turning a Firefox build job
into a series of actions/steps/commands to run on a slave. And, lucky
for us, the activity of a slave is captured and saved to text log files!
If you've ever used <a href="https://tbpl.mozilla.org/">TBPL</a>, you've almost
certainly clicked a link to view one of these logs.</p>
<p>In this section, I'll describe the steps performed in
<a href="https://ftp.mozilla.org/pub/mozilla.org/firefox/tinderbox-builds/mozilla-central-linux64/1371941584/mozilla-central-linux64-bm62-build1-build35.txt.gz">this log</a>
from a recent <em>mozilla-central</em> build on a 64-bit Linux machine.
I will be paying particular attention to steps that affect the
build environment (for reasons that will be revealed in my critique
below).</p>
<p>If you load our log of interest next to
<a href="https://hg.mozilla.org/build/buildbotcustom/file/bdcca6f7b6c2/process/factory.py#l764">factory.py</a>
from <em>buildbotcustom</em>, you can start to see how they are related.
You may notice <em>self.addStep()</em> calls in <em>factory.py</em> correspond to
<em>========= Started</em> ... <em>========= Finished</em> sections in the log.
That's no accident: every <em>addStep()</em> call produces a section like
that in the log.</p>
<p>Now let's look at some of those steps in detail.</p>
<p>The job/log contains a number of <em>set property</em> steps. Search for
<em>set props</em> and you'll find them in the log. These steps define named
properties in a hash map buildbot uses to represent the current
configuration/state. Think of these properties as a way for buildbot to
communicate metadata between masters and slaves.</p>
<p>One of the first interesting steps we see is the cloning of the
<a href="https://hg.mozilla.org/build/tools">tools repository</a>. Search for
<em>Started clone build tools</em> and you'll find it. This repository contains
a lot of support tools and scripts used by all parts of automation.
There's lots of useful tools in there!</p>
<p>Skipping over the steps that check whether to clobber the builder or
purge old content from disk, the next build steps relevant to our
interests involve the population of a <em>mock</em> environment.
Search for <em>Started mock-tgt mozilla-centos6-x86_64</em> to find it in the
logs.</p>
<p><a href="https://fedoraproject.org/wiki/Projects/Mock">Mock</a> is a piece of
software that manages <a href="https://en.wikipedia.org/wiki/Chroot">chroots</a>.
It was written by the Fedora project for creating isolated build
environments for software packages. For reasons unknown to me,
Mozilla runs a forked version of mock called
<a href="https://github.com/jhford/mock_mozilla">mock_mozilla</a>.</p>
<p>The build job creates a fresh mock environment on every build. (This is
clearly indicated by the <em>INFO: chroot
(/builds/mock_mozilla/mozilla-centos6-x86_64) unlocked and deleted</em>
line in the log.) Later on, builds are performed inside this mock
environment. This means that every build job is mostly isolated from
both the underlying operating system and all build jobs that came
before.</p>
<p>You can see the creation of the new mock environment by looking for the
<em>mock_mozilla -r mozilla-centos6-x86_64 --init</em> command in the log. This
is using the <em>mozilla-centos6-x86_64</em> configuration file to create the new
environment. This file is managed by Puppet, so you can
<a href="https://hg.mozilla.org/build/puppet/file/6f7b4a33af2c/modules/mockbuild/files/mozilla-centos6-x86_64.cfg">see it</a>
in the <em>puppet</em> repository. The
<a href="https://hg.mozilla.org/build/puppet/file/6f7b4a33af2c/modules/mockbuild/files/mozilla-centos6-x86_64.cfg#l11">setup command</a>
on line 11 is the most important line in this file: it defines what
commands to run to initialize the new mock environment.</p>
<p>Populating the mock environment takes a number of buildbot steps. After
copying a bunch of files into the mock/chroot, the mock environment is
further initialized by installing a number of packages. Search for
<em>Started mock-install</em> in the log. Yum is being used to install a number
of packages required to build Firefox. This package list appears to
come from
<a href="https://hg.mozilla.org/build/buildbot-configs/file/e8b27b8b7216/mozilla/config.py#l208">config.py</a>
in the <em>buildbot-configs</em> repository. These packages are downloaded from
a Yum repository hosted by Mozilla. Altogether, 249 new packages
consuming 821 MB are installed during this step!</p>
<p>After the <em>mock</em> environment is created, the <em>mozharness</em> repository is
removed, re-cloned, and updated to the <em>production</em> branch. After that,
we pull changes from <em>mozilla-central</em> and update the local checkout to
the revision we've been told to build.</p>
<p>If you search for <em>Started got mozconfig</em>, you'll find where the
<em>mozconfig</em> file (the build system configuration file) is acquired.</p>
<p>After that, the
<a href="https://wiki.mozilla.org/ReleaseEngineering/Applications/Tooltool">tooltool</a>
configuration is consulted. Tooltool is essentially a content-addressable
file store: files are stored and retrieved by the hash value of their
content. A manifest file inside <em>mozilla-central</em> defines the set of
files to fetch from tooltool at build time. At this step of the build,
that file is consulted and listed files are downloaded. While the Linux
manifest is currently empty, the
<a href="https://hg.mozilla.org/mozilla-central/file/e7e9726025da/browser/config/tooltool-manifests/macosx64/releng.manifest">OS X tooltool manifest</a>
defines the digest of the Clang archive to use to build the tree.</p>
<p>Since tooltool files are addressed by content (not merely by name), this
means that the same file will be fetched no matter when the build runs.
In other words, behavior is constant as the contents of the tooltool
repository itself change (or at least it should be).</p>
<p>After <em>tooltool</em> contents sync, we finally arrive at the actual build
step. Search for <em>Started compile</em> in the log. The important detail here
is that <em>mock_mozilla</em> is used to build firefox with <em>client.mk</em> inside
the fresh mock/chroot environment.</p>
<p>After building, we move on to other tasks, such as creating a
distributable package, running tests, etc. I'm just going to glance over
them because there's a lot going on and it would take a long time to
explain it all! I encourage you to look at the steps in the log and
learn.</p>
<p>While these steps are going on, the buildbot master is notified that the
build and packaging aspect of the job has completed (sometime before
<em>make check</em> is executed). Upon receiving this success notification, the
buildbot master scheduled derived jobs, notably all the test suites
(reftests, mochitests, xpcshell tests, etc). This scheduling occurs
before <em>make check</em> has completed so overall turnaround time is reduced
as much as possible.</p>
<p>Finally, at the end of the log, the slave/machine is rebooted. At this
point, the job has finished. TBPL colors the <em>B</em> next to the job green
to signal successul completion. The slave waits for its next job from
the buildbot master.</p>
<p>And that is how Firefox is built! I could go into details for all of the
derived test jobs, but I won't, as that would take a lot of effort! I
leave that as an exercise for the reader.</p>
<h2>Analysis</h2>
<p>The Firefox build automation is complex and composed of many pieces.
It's a testament to a lot of people's hard work that it works as well as
it does!</p>
<p>From my experience at a previous job managing large numbers of servers
in a production datacenter, I commend Release Engineering for deploying
Puppet to help ensure the machines performing Firefox's build automation
are in a consistent state. I also like how <em>mock</em> is used to mostly
isolate build jobs from one another. These are both very important to
ensure Firefox is built consistently over time.</p>
<p>The on-going migration of automation logic from <em>buildbotcustom</em> to
<em>mozharness</em> is a fantastic project and I hope it is completed soon.
I hold hope that one day we can integrate <em>mozharness</em> into the local
development workflow (likely transparently through tools like <em>mach</em>)
and local developers can invoke actions using the same code path as the
official automation infrastructure.</p>
<h2>Areas for improvement</h2>
<p>The Firefox build automation largely works well. And I don't mean to
take away from that. However, there are a number of areas where
things could be improved. In this section, I'll talk about some of them.</p>
<p>Before I get into details, let me share an experience I had about a year
ago.</p>
<h3>A tale of modifying the xpcshell test harness</h3>
<p>In April 2012, I was writing a lot of JavaScript testing code and was
frustrated at how difficult it was to share test helper code between
tests. I filed
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=748490">bug 748490</a>
to request a new feature in the JavaScript test harnesses: the ability
to create testing-only JavaScript modules that weren't shipped as part
of Firefox. This would encourage code reuse among tests and make writing
tests easier. I thought it would be a relatively simple feature to
implement!</p>
<p>And, it was. At first. The initial implementation landed two weeks after
I filed the bug (it didn't require too much effort, but I was busy with
others tasks). It landed without incident. Although, nothing was using
it and there was no test coverage. However, my local development started
relying on it and things were working just fine.</p>
<p>When I <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=755196">attempted</a>
to actually land a test that made use of this new feature, it failed
because the new directory for these shared modules
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=755339">wasn't being archived</a>.
Simple enough to fix, right? Wrong. Start reading
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=755339#c4">bug 755339 from comment #4</a>.
It is a trail of agony. I had to uplift my change to all
the major branches. Then, once that was done, <em>buildbotcustom</em> could
be updated. Uplifts were performed on May 24. <em>buildbotcustom</em> was
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=755339#c15">pushed out to production</a>
a week later on May 31. It immediately
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=755339#c16">broke the world</a>.
At the time, philor says it was the worst tree bustage he'd ever seen.
Literally every tree was red. Achievement unlocked. A workaround
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=755339#c17">was quickly devised</a>
on May 31 (after the <em>buildbotcustom</em> change was backed out to restore
working automation) and landed. Again, it had to be uplifted to all the
trees. This patch conflicted when applied on older trees and I
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=755339#c23">accidentally committed a typo</a>
and broke beta, release, and esr in the process. I got an earful for
breaking these trees and lost a lot of <em>street cred</em> with the sheriffs
(who are charged with keeping law and order in the land of the source
trees). The <em>buildbotcustom</em> change
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=757460#c21">finally landed</a>
on June 7 and stuck.</p>
<p>Finally, my initial idea of adding testing-only JavaScript modules had been
implemented and was available for all to use. It only required uplifting
a patch to all project branches, having Release Engineering reconfigure
<em>buildbotcustom</em>, and breaking all the trees in the process. This
experience was truly WTFOMGBBQ. And, the agony above was from adding a
seemingly innocuous feature to a single test harness. Can you imagine
what it's like to add a new test harness to automation?!</p>
<h3>In-tree automation configs different from Release Engineering's</h3>
<p>The above example demonstrates many shortcomings in the current
automation infrastructure. The first one I will talk about is that the
in-tree automation configs (how to perform a specific automation job,
such as run an individual test harness) are almost completely different
from what Release Engineering runs on the official infrastructure!</p>
<p>A year ago, <em>mozilla-central</em> had
<a href="https://hg.mozilla.org/mozilla-central/file/e24391ffbe7e/testing/testsuite-targets.mk">testsuite-targets.mk</a> -
a make file defining targets like <em>xpcshell-tests</em> and
<em>mochitest-plain</em> that allowed developers to run these test suites
locally. Release Engineering had <em>buildbotcustom</em>, which didn't use
<em>testsuite-targets.mk</em> at all. While invoking most test harnesses is
simply a matter of formulating arguments for a Python script, that logic
was duplicated between <em>testsuite-targets</em> and <em>buildbotcustom</em>.</p>
<p>Today, <em>Release Engineering</em> has been porting job invocation code to
<em>mozharness</em>. And, I have been encouraging people to locally run tests
with <em>mach</em>. Initially, mach commands executed make. However, commands
are now bypassing make and calling into the Python test harnesses
natively. This allows more advanced behavior since mach has more control
and insight into the underlying test harness. The downside is mach is
now reinventing logic.</p>
<p>So, we now have 3 or 4 separate implementations for performing many of
our automation jobs. Medium term, you figure Release Engineering
consolidates all the <em>buildbotcustom</em> logic into <em>mozharness</em>,
eliminating 1. I also think it is inevitable that <em>testsuite-targets</em> is
refactored to invoke mach commands or is just removed altogether. But
that still leaves us with 2 independent implementations!</p>
<p><strong>I believe we should work towards consolidating the logic for job
invocation to inside mozilla-central.</strong> The commands developers run
locally should be as similar as possible to what runs on official
automation infrastructure. Any differences introduce potential for
different results. Differences also increase the burden to roll out
changes. I would argue that an in-tree change should be all that is
necessary to change the behavior of official automation infrastructure.</p>
<p>How this is accomplished, I'm not entirely certain. In my ideal world,
I think <em>mozharness</em> would live in tree. Although, I understand that may
not be practical because much of what <em>mozharness</em> does involves
downloading just-built packages, uploading results to a server, etc. I
think a middle ground that accomplishes most of what we seek is for the
Release Engineering configs (<em>mozharness</em>) to contain as little logic as
possible for actual job invocation and let something in-tree do the
rest. For example, the <em>mozharness</em> job for the xpcshell test harness
would simply be <em>execute the run-xpcshell-tests script from the tests
archive.</em> <em>mozilla-central</em> could then have full domain over what
exactly is done. If <em>mozilla-central</em> changes, everyone picks up those
changes immediately.</p>
<h3>Local run-time environments different from official ones</h3>
<p>Similar in vein to the previous section is that there are discrepancies
between local run-time environments and official ones. By run-time
environment, I mean the state of the operating system (installed
packages, configuration settings, etc). This plays an important role in
determining how an automation job executes. An obvious example is the
compiler toolchain. GCC 4.5 is obviously going to have different
behavior from GCC 4.7.</p>
<p>While Release Engineering has taken steps to ensure consistency in the
configuration of the machines powering the official automation
infrastructure, local machine configurations are effectively living in
the wild west. Developers are effectively unable to recreate the
official automation environment. This lowers the liklihood that a local
build will have the same outcome when performed on official automation
infrastructure.</p>
<p>While supporting diverse run-time environments will result in greater
compatibility and is thus a good thing, I think it is important that
local developers have the ability to recreate the official run-time
environment as closely as possible. This will raise confidence that
local results can be trusted and should cut down on development
cost by reducing the number of Try pushes and reducing development
cycles.</p>
<p>Recreating the official run-time environment varies in difficulty
depending on the operating system. For Linux, it should actually be
pretty easy! For the build environment, Mozilla simply needs to package
the <em>mock</em> environment used to build or at least could publish a script
used to create said environment. In
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=886226">bug 886226</a>, I
made an initial stab at this by creating a Vagrantfile that will
kinda/sorta recreate the official 64-bit Linux build environment. I even
published an archive of the <em>mock</em> environment (which can be imported
into <em>Docker</em>). As pointed out on the bug, my work isn't perfect. But
it's a start. And it's better than what developers have today to
reproduce the official environments.</p>
<p>If we decide publishing archives of chroot environments is the way to
go, I believe we could extend the Linux solution to OS X as well. OS X
has chroot. It also has a sandboxing facility (<em>man sandbox</em>). There are
also tools like <a href="http://freecode.com/projects/jailkit">jailkit</a>. Also,
using chroot environments will also likely make our automation faster
since using archives will almost surely be faster than recreating the
environment on every job run.
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=851294">Bug 851294</a> has
been filed to track this.</p>
<p>What about Windows? Well, I don't know. We sort of have an environment
with <a href="https://ftp.mozilla.org/pub/mozilla.org/mozilla/libraries/win32/MozillaBuildSetup-Latest.exe">MozillaBuild</a>.
But, it's not isolated from the rest of the operating system like chroot
environments are. Modulo Windows, two out of three tier one platforms
isn't too bad!</p>
<p>Now, even if the software environment is similar, hardware differences
can also affect results. Unfortunately, there's little that can be done
on this front aside from having everybody use the same hardware models.
That's not going to happen. So let's pretend we don't have that problem.</p>
<h3>Configurations change over time</h3>
<p>I recently wrote a
<a href="/blog/2013/06/24/the-importance-of-time-on-automated-machine-configuration/">post on the importance of time on machine configurations</a>.
The gist is that configurations always pulling from version control tip
or relying on external resource often vary with time and aren't truly
idempotent. This makes it difficult to reproduce specific configurations
at future points in time.</p>
<p>Unfortunately, Mozilla's build automation is highly susceptible to
configuration variance over time. There are many examples.</p>
<p>The buildbot configuration is periodically pushed to the
infrastructure. A job will inherit the config that is currently
deployed. If you make a backwards incompatible change to the buildbot
configs and push an old revision of mozilla-central, things will blow
up.</p>
<p>There are two time-dependent aspects of Puppet bootstrapping. First, the
Puppet configs (like buildbot configs) are periodically pushed to a
central master server. Whichever version is deployed at a given time is
the version picked up by the automation job. Second, we don't do a good
job of pinning versions inside the Puppet config. Here are the
<a href="https://hg.mozilla.org/build/puppet/file/6f7b4a33af2c/modules/packages/manifests/mercurial.pp">Mercurial</a>,
<a href="https://hg.mozilla.org/build/puppet/file/6f7b4a33af2c/modules/packages/manifests/mock.pp">mock</a>,
and <a href="https://hg.mozilla.org/build/puppet/file/6f7b4a33af2c/modules/packages/manifests/mozilla/py27_mercurial.pp">Python</a>
manifests using the <em>latest</em> package version. This means if a new
version of a package is added to
<a href="http://puppetagain.pub.build.mozilla.org/data/repos/yum/">Mozilla's Yum repositories</a>
that new package version will be deployed on the next Puppet sync.
This is definitely not time independent. Fortunately, the base operating
system configuration for Linux isn't terribly important because of the
<em>mock</em> environment. But, it still varies.</p>
<p>Like the base operating system, the mock environment is full of
dependence on time. First, the config file itself is managed by Puppet
and thus susceptible to its time-dependent behavior. Second, the
packages installed in the mock environment aren't version pinned.
This means that whatever packages deployed in
<a href="http://puppetagain.pub.build.mozilla.org/data/repos/yum/">Mozilla's Yum repositories</a>
will be used. So, every time the Yum package repository is updated, we
potentially switch the configuration of our build environment. On the
surface, this terrifies me. Maybe we have a strict update policy in
place to prevent excessive package updates. The
<a href="http://puppetagain.pub.build.mozilla.org/data/repos/yum/mirrors/centos/6/latest/os/x86_64/">modified times</a>
of packages on the server seems to indicate that. Even if we didn't
update the package repository, it still seems a bit fragile: I'd much
prefer to pin package versions everywhere than rely on the content of
a Yum server.</p>
<p>The default branch of the <a href="https://hg.mozilla.org/build/tools">tools repository</a>
is always checked out at build time. As new revisions are added to this
repository, builds will pick them up immediately. If you make a
backwards incompatible change to the tools repository, old revisions may
no longer build.</p>
<p>The production branch of the
<a href="https://hg.mozilla.org/build/mozharness/">mozharness repository</a> is
always used during jobs. Again, if <em>mozharness</em> changes, every future
job sees these changes.</p>
<p>The takeaway here is that many of the tightly-related
systems/repositories aren't linked in any way. The automation
configuration simply pulls the tip of each. We run into problems when we
wish to make backwards incompatible changes. If you make one, you first
have to update all repositories to be compatible. This is a huge pain
(see my experience above). Furthermore, it makes it impossible to have
successful automation runs from old revisions of those repositories!</p>
<p>The solution to this mess is to pin versions and configs everywhere.
The repositories being put through automation (namely <em>mozilla-central</em>)
should contain revisions of the configs to use. It should say <em>I want to
use revision X of mozharness, revision Y of the build machine
configuration, etc.</em> This will enable much more consistent automation
output over time. It cuts down on surprises (<em>did behavior change on July
14 because of a change to mozilla-central or to a new automation config
being rolled out to the server?</em>). It allows people to build very old
packages. This means Mozilla wouldn't need to store terabytes of old
builds around (we could just trigger the build again and get the same
output).</p>
<p>I recognize that deterministic automation configuration is likely not
completely achievable. But, that doesn't mean we shouldn't work towards
it. Having something better than today enables so many more useful
scenarios and flexibility in our automation. Let me explain.</p>
<p>Say you want to add or remove a test harness. Or, maybe you want to add
a required argument or remove an obsolute argument from a test harness.
The procedure from doing this today is far from trivial. It's not enough
to simply land your change in mozilla-central and be done with it. Instead,
you need to land support in <em>buildbotcustom</em> or <em>mozharness</em>, prepare to
land in mozilla-central, then coordinate with Release Engineering to have your
changes landed around the time of a server deployment. And since changes
likely affect multiple trees, you're likely also landing things in
inbound, fx-team, services-central, possibly aurora, beta, and release,
etc. If you aren't landing in aurora, beta, release, esr, b2g, etc, you
need to remember to have your change merged into these server configurations
when those trees inherit your code (although Release Engineering is
typically pretty good about tracking this and doing it for you).</p>
<p>Contrast this with simply making a backwards incompatible change by
checking in support in <em>mozharness</em> then making the change in
<em>mozilla-central</em> along with a revision bump of the <em>mozharness</em>
revision to use. When that changeset is pushed to the infrastructure, a
compatible version of <em>mozharness</em> is used. When that change gets merged
into other trees, the appropriate <em>mozharness</em> revision is used. No
extra work needed. Utopia. You just made A*Team and Release Engineering
much more productive by eliminating a lot of overhead.</p>
<h2>Conclusion</h2>
<p>The Mozilla automation infrastructure is a complex beast. There are many
moving parts and separate systems. Any newcomer to Mozilla should simply
stand in awe that so many systems seemlessly work so well together.</p>
<p>There are improvements that can be made, sure (especially in the area of
deterministic behavior over time). But, I think with the <em>mozharness</em>
work and the <em>Puppetization</em> of the server infrastructure that Mozilla
is on the right course. I look forward to a future where the source code
in <em>mozilla-central</em> and the automation infrastructure are more tightly
integrated. We're trending there. Give it time.</p>]]></content>
  </entry>
</feed>
